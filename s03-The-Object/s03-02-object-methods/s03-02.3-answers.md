# Ответы

1. **Метод объекта в JavaScript** – это функция, которая является свойством объекта и может быть вызвана в его контексте.  
   *Методы определяют поведение объекта и работают с его данными.*

2. **Способы записи метода:**
  - `sayHi: function() { ... }` (классический способ)
  - `sayHi() { ... }` (сокращённая запись, ES6+)  
    *Оба варианта работают одинаково, но второй короче и удобнее.*

3. **Методы рекомендуется называть глаголами**, потому что они выполняют действия (`get`, `set`, `calculate` и т. д.).  
   *Это улучшает читаемость кода и делает его логичнее.*

4. **Метод вызывается через точку:** `объект.метод()`.  
   *Например, `user.sayHi()` выполнит функцию `sayHi` в контексте `user`.*

5. **Свойство объекта** хранит данные, а **метод** выполняет действия.  
   *Свойство: `name: "Alex"`, метод: `getName() { return this.name; }`.*

6. **`this` внутри метода ссылается на сам объект**, в котором он определён.  
   *Если вызвать `obj.method()`, `this` будет равен `obj`.*

7. **Проблема:** `this` теряется, если метод передаётся как callback (например, в `setTimeout`).  
   *Внутри `function() { ... }` `this` будет `window` (или `undefined` в strict mode).*

8. **Решение проблемы с `this`:**
  - Использовать стрелочную функцию (не имеет своего `this`).
  - Сохранить `this` в переменную (`const self = this`).  
    *Стрелочные функции наследуют `this` из внешнего контекста.*

9. **Стрелочные функции не имеют своего `this`**, поэтому берут его из окружающей области видимости.  
   *Это делает их удобными для колбэков внутри методов.*

10. **Код выведет `undefined`**, потому что `setTimeout` вызывает метод без контекста (`this` теряется).  
    *Решение: обернуть вызов в стрелочную функцию: `setTimeout(() => obj.logName(), 1000)`.*

11. **Поверхностное копирование** копирует только первый уровень, **глубокое** – все вложенные объекты.  
    *Поверхностное: `{ ...obj }`, глубокое: `structuredClone(obj)`.*

12. **Поверхностное копирование:**
  - `const copy = { ...obj }` (spread-оператор)
  - `const copy = Object.assign({}, obj)`  
    *Оба способа копируют только верхний уровень.*

13. **Ограничение:** Вложенные объекты копируются по ссылке.  
    *Изменения в копии повлияют на оригинал, если свойство – объект.*

14. **Глубокое копирование:**
  - `JSON.parse(JSON.stringify(obj))` (не копирует функции и `undefined`)
  - `structuredClone(obj)` (современный способ, поддерживает больше типов)  
    *`structuredClone` – предпочтительный вариант.*

15. **`JSON`-метод не скопирует:**
  - Функции
  - `undefined`
  - Циклические ссылки  
    *Выбросит ошибку при попытке клонировать такие данные.*

16. **`structuredClone`** создаёт глубокую копию, включая вложенные объекты, массивы, `Map`, `Set` и др.  
    *Работает лучше `JSON`, но не поддерживает функции и прототипы.*

17. **`Object.keys()`** – массив ключей, **`Object.values()`** – массив значений, **`Object.entries()`** – массив пар `[ключ, значение]`.  
    *Полезны для итерации по объекту.*

18. **`Object.freeze()`** запрещает любые изменения, **`Object.seal()`** – только добавление/удаление свойств.  
    *`freeze` делает объект полностью неизменяемым.*

19. **Проверить заморозку:** `Object.isFrozen(obj)`.  
    *Вернёт `true`, если объект заморожен.*

20. **Цикл `for...in`** перебирает все ключи, включая унаследованные.  
    *Чтобы отфильтровать свои свойства, нужно проверять `obj.hasOwnProperty(key)`.*

21. **`hasOwnProperty`** проверяет только собственные свойства, **`in`** – и цепочку прототипов.  
    *Пример: `'toString' in obj` → `true`, `obj.hasOwnProperty('toString')` → `false`.*

22. **Неизменяемое свойство:**
    ```javascript
    Object.defineProperty(obj, 'prop', {
      value: 42,
      writable: false,
    });
    ```
    *Теперь `obj.prop = 100` не сработает.*

23. **Дескрипторы свойств** – настройки свойства (`value`, `writable`, `enumerable`, `configurable`).  
    *Получить их: `Object.getOwnPropertyDescriptor(obj, 'prop')`.*

24. **Запретить добавление свойств:** `Object.preventExtensions(obj)`.  
    *Существующие свойства можно изменять, но новые добавить нельзя.*

25. **Разница:**
  - `preventExtensions()` – нельзя добавлять свойства.
  - `seal()` – нельзя добавлять/удалять, но можно изменять.
  - `freeze()` – полная неизменяемость.

26. **Объект `calculator`:**
    ```javascript
    const calculator = {
      a: 0,
      b: 0,
      add() { return this.a + this.b; },
      subtract() { return this.a - this.b; },
      // Аналогично для multiply и divide
    };
    ```
    *Методы работают с `this.a` и `this.b`.*

27. **Функция `deepEqual`:**
    ```javascript
    function deepEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }
    ```
    *Упрощённый вариант (лучше использовать рекурсивное сравнение).*

28. **Геттер и сеттер для `fullName`:**
    ```javascript
    const user = {
      firstName: 'John',
      lastName: 'Doe',
      get fullName() { return `${this.firstName} ${this.lastName}`; },
      set fullName(value) { [this.firstName, this.lastName] = value.split(' '); },
    };
    ```
    *Теперь можно читать и изменять `user.fullName` как свойство.*

29. **"Приватное" свойство:**
    ```javascript
    const obj = {};
    Object.defineProperty(obj, '_secret', {
      value: 123,
      writable: false,
      enumerable: false,
    });
    ```
    *`_secret` нельзя изменить, и оно не видно в `Object.keys()`.*

30. **Функция для замены ключей и значений:**
    ```javascript
    function invert(obj) {
      return Object.fromEntries(
        Object.entries(obj).map(([key, value]) => [value, key])
      );
    }
    ```
    *`Object.entries()` + `Object.fromEntries()` делают код лаконичным.*
