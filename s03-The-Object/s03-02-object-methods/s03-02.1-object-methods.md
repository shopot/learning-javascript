# Методы объектов

Объекты в JavaScript - это фундаментальная структура данных, которая позволяет хранить коллекции свойств и методов. В этой статье мы подробно рассмотрим различные аспекты работы с методами объектов.

## Собственные методы объектов

Методы объекта - это функции, которые являются свойствами объекта. Они позволяют объекту "действовать".

### Создание методов

```javascript
const user = {
  name: "Алексей",
  age: 30,
  
  // Метод объекта
  sayHi: function() {
    console.log(`Привет, меня зовут ${this.name}!`);
  },
  
  // Сокращенная запись метода (ES6)
  sayAge() {
    console.log(`Мне ${this.age} лет.`);
  }
};

user.sayHi(); // Привет, меня зовут Алексей!
user.sayAge(); // Мне 30 лет.
```

**Рекомендации:**
- Используйте сокращенную запись методов (sayAge()) для лучшей читаемости кода.
- Называйте методы глаголами, чтобы подчеркнуть, что это действия (getUser, calculateTotal и т.д.).
- Группируйте связанные методы вместе для лучшей организации кода.

## Ключевое слово `this`

Ключевое слово `this` ссылается на объект, в контексте которого был вызван метод.

### Как работает this

```javascript
const car = {
  brand: "Toyota",
  model: "Camry",
  
  showInfo() {
    console.log(`Марка: ${this.brand}, Модель: ${this.model}`);
  }
};

car.showInfo(); // Марка: Toyota, Модель: Camry
```

**Проблемы с this:**
```javascript
const car = {
  brand: "Toyota",
  models: ["Camry", "Corolla", "RAV4"],
  
  showModels() {
    this.models.forEach(function(model) {
      // Здесь this не ссылается на объект car!
      console.log(`${this.brand} ${model}`); // undefined
    });
  }
};

car.showModels();
```

**Решение проблем с this:**

1. Использование стрелочных функций (они не имеют своего this):
```javascript
showModels() {
  this.models.forEach(model => {
    console.log(`${this.brand} ${model}`); // Теперь работает!
  });
}
```

2. Сохранение this в переменную:
```javascript
showModels() {
  const self = this;
  this.models.forEach(function(model) {
    console.log(`${self.brand} ${model}`);
  });
}
```

**Рекомендации:**
- В методах объекта используйте обычные функции, если вам нужен доступ к this.
- В callback-функциях внутри методов используйте стрелочные функции или сохраняйте this в переменную.
- Будьте осторожны при передаче методов объекта как callback'ов - this может потеряться.

## Копирование и создание объектов

### Поверхностное копирование

```javascript
const original = { a: 1, b: { c: 2 } };

// 1. Оператор spread (ES6)
const copy1 = { ...original };

// 2. Object.assign()
const copy2 = Object.assign({}, original);
```

**Ограничения:** Эти методы создают только поверхностную копию. Вложенные объекты копируются по ссылке.

### Глубокое копирование

1. JSON методы (имеет ограничения - не копирует функции, undefined и т.д.):
```javascript
const deepCopy = JSON.parse(JSON.stringify(original));
```

2. structuredClone (современный способ):
```javascript
const deepCopy = structuredClone(original);
```

**Рекомендации:**
- Для простых объектов без методов и специальных типов используйте spread или Object.assign().
- Для глубокого копирования используйте structuredClone, где это возможно.
- Для сложных случаев (с функциями, классами) рассмотрите использование библиотек типа lodash.cloneDeep.

## Встроенные методы `Object`

### Основные методы Object:

1. Object.keys(obj) - возвращает массив ключей объекта:
```javascript
const user = { name: "Алексей", age: 30 };
console.log(Object.keys(user)); // ["name", "age"]
```

2. Object.values(obj) - возвращает массив значений:
```javascript
console.log(Object.values(user)); // ["Алексей", 30]
```

3. Object.entries(obj) - возвращает массив пар [ключ, значение]:
```javascript
console.log(Object.entries(user)); // [["name", "Алексей"], ["age", 30]]
```

4. Object.freeze(obj) - делает объект неизменяемым:
```javascript
const frozen = Object.freeze({ a: 1 });
frozen.a = 2; // Ошибки не будет, но значение не изменится
```

5. Object.seal(obj) - запрещает добавлять/удалять свойства, но позволяет изменять существующие:
```javascript
const sealed = Object.seal({ a: 1 });
sealed.a = 2; // Работает
sealed.b = 3; // Не добавит новое свойство
```

**Рекомендации:**
- Используйте Object.keys() для итерации по свойствам объекта.
- Object.freeze() и Object.seal() полезны для создания неизменяемых структур данных.
- Object.entries() удобен для преобразования объекта в массив.

## Методы для работы со свойствами объектов

### Проверка свойств:

1. obj.hasOwnProperty(prop) - проверяет, есть ли свойство в самом объекте (не в прототипе):
```javascript
const obj = { a: 1 };
console.log(obj.hasOwnProperty('a')); // true
console.log(obj.hasOwnProperty('toString')); // false (из прототипа)
```

2. prop in obj - проверяет наличие свойства в объекте или его прототипе:
```javascript
console.log('a' in obj); // true
console.log('toString' in obj); // true
```

### Управление свойствами:

1. Object.defineProperty() - позволяет точно настроить свойство:
```javascript
const obj = {};
Object.defineProperty(obj, 'readOnly', {
  value: 42,
  writable: false,
  enumerable: true,
  configurable: false
});

obj.readOnly = 100; // Не изменится (в strict mode будет ошибка)
```

2. Object.getOwnPropertyDescriptor() - получает дескриптор свойства:
```javascript
const descriptor = Object.getOwnPropertyDescriptor(obj, 'readOnly');
console.log(descriptor);
// { value: 42, writable: false, enumerable: true, configurable: false }
```

3. Object.preventExtensions() - запрещает добавлять новые свойства:
```javascript
const obj = { a: 1 };
Object.preventExtensions(obj);
obj.b = 2; // Не добавится (в strict mode будет ошибка)
```

**Рекомендации:**
- Для проверки свойств предпочитайте hasOwnProperty() или Object.hasOwn() (новый метод).
- Используйте Object.defineProperty() для создания свойств с особой логикой (геттеры/сеттеры).
- Методы управления свойствами полезны для создания защищенных объектов и API.
