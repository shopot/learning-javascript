# Ответы для "Цикл `for...in`"

1. **Цикл `for...in` перебирает ключи (названия свойств) объекта.**  
   Пояснение: Он проходит по всем перечисляемым свойствам объекта, включая унаследованные (если не используется проверка `hasOwnProperty`).

2. **Значение свойства получают через квадратные скобки: `object[key]`.**  
   Пояснение: В цикле `for...in` ключ хранится во временной переменной, и через `obj[key]` можно получить соответствующее значение.

3. **`for...in` не гарантирует порядок и выводит индексы, а не значения.**  
   Пояснение: Для массивов лучше использовать `for...of` или `forEach()`, так как `for...in` может перебирать не только индексы, но и методы прототипа.

4. **`Object.keys(obj)` возвращает массив ключей объекта.**  
   Пояснение: Этот метод принимает объект и возвращает массив строк — имён его свойств.

5. **`Object.values(obj)` возвращает массив значений объекта.**  
   Пояснение: Метод извлекает все значения свойств объекта и помещает их в массив.

6. **`Object.entries(obj)` возвращает массив пар `[ключ, значение]`.**  
   Пояснение: Каждый элемент массива — это подмассив из двух элементов: ключа и соответствующего значения.

7. **`for(let key of Object.keys(obj)) { ... }`.**  
   Пояснение: `Object.keys()` превращает ключи в массив, который можно перебрать через `for...of`.

8. **`for(const [key, value] of Object.entries(obj)) { ... }`.**  
   Пояснение: Деструктуризация позволяет сразу получить ключ и значение из каждой пары.

9. **`Object.keys(obj).length`.**  
   Пояснение: Так как `Object.keys()` возвращает массив ключей, его длина равна количеству свойств.

10. **`Object.fromEntries(Object.entries(obj).filter(([k, v]) => typeof v === 'string'))`.**  
    Пояснение: `Object.entries()` преобразует объект в массив пар, `filter` оставляет только строки, а `fromEntries` собирает обратно в объект.

11. **`Object.values(obj).reduce((sum, val) => sum + val, 0)`.**  
    Пояснение: `Object.values()` извлекает числа, а `reduce()` суммирует их.

12. **`for...in` перебирает ключи, а `for...of` — значения (но для объектов напрямую не работает).**  
    Пояснение: `for...of` требует итерируемого объекта (массива, строки и т. д.), а `for...in` работает с любыми объектами.

13. **`Object.entries(obj)`.**  
    Пояснение: Именно этот метод разбивает объект на пары ключ-значение в виде массива.

14. **`for...of` с `Object.keys()/values()/entries()`.**  
    Пояснение: Преобразование в массив гарантирует порядок, в отличие от `for...in`.

15. **`Object.keys(obj).forEach(key => console.log(key, obj[key]))`.**  
    Пояснение: `Object.keys()` даёт массив ключей, а `forEach` перебирает их.

16. **`for(let value of Object.values(obj)) { console.log(value) }`.**  
    Пояснение: `Object.values()` сразу возвращает массив значений.

17. **`Object.fromEntries(entriesArray)`.**  
    Пояснение: Метод преобразует массив пар `[ключ, значение]` обратно в объект.

18. **Нет, `Object.values()` возвращает только значения, не индексы.**  
    Пояснение: Для индексов массива используется обычный цикл `for` или `Array.keys()`.

19. **`Object.entries()` или `Object.keys()/values()` с циклами массивов.**  
    Пояснение: Эти методы позволяют работать с объектом как с массивом для перебора.

20. **`Object.fromEntries(Object.entries(obj).map(([k, v]) => [k, v * 2]))`.**  
    Пояснение: `Object.entries()` разбирает объект, `map` изменяет значения, `fromEntries` собирает обратно.
