# Ответы по теме "Наследование и Прототипы"

1. Наследование — это механизм ООП, позволяющий одному классу (дочернему) использовать свойства и методы другого класса (родительского).
   Это означает, что можно создать общий класс с повторно используемой логикой, а на его основе создавать более специфические классы, которые автоматически получают весь его функционал.

2. Для создания дочернего класса используется ключевое слово `extends`.
   Это слово указывает JavaScript, что объявляемый класс должен наследовать от другого класса, указанного после `extends`.

3. Ключевое слово `super` в конструкторе дочернего класса используется для вызова конструктора родительского класса.
   Это гарантирует, что свойства, определенные в родительском классе, будут правильно проинициализированы в объекте дочернего класса, прежде чем мы начнем добавлять собственные свойства дочернего класса.

4. Если не вызвать `super()` в конструкторе дочернего класса, будет выброшена ошибка ReferenceError.
   Это происходит потому, что до вызова `super()` не существует `this`-контекста для дочернего класса, так как именно вызов `super()` создает базовый объект на основе родителя.

5. Да, дочерний класс может обращаться к методам и свойствам родительского класса. Например, экземпляр `Motorcycle` может вызывать методы `accelerate()` и `move()`.
   Это является основной целью наследования — повторное использование кода и создание иерархии, где потомки имеют доступ к функционалу предков.

6. Нет, родительский класс не может обращаться к уникальным методам и свойствам дочернего класса.
   Это следует из принципа наследования: потомок знает о предке, но предок ничего не знает о своих потомках и их специфическом функционале.

7. Прототип — это механизм в JavaScript, который позволяет объектам наследовать свойства и методы от других объектов.
   Каждый объект имеет внутреннюю ссылку на другой объект (свой прототип), и эта цепочка прототипов является основой для наследования в JavaScript.

8. Добавить новый метод к существующему классу после его объявления можно, обратившись к свойству `prototype` этого класса и присвоив ему новую функцию.
   Например: `ClassName.prototype.newMethod = function() {...}`. Это стандартный способ динамического расширения функциональности классов и встроенных объектов.

9. Да, методы, добавленные через `prototype`, становятся доступны всем экземплярам этого класса, даже тем, которые были созданы до добавления метода.
   Это работает потому, что при обращении к свойству или методу объекта JavaScript ищет его не в самом объекте, а в цепочке прототипов, которая динамически обновляется.

10. Нет, если изменить свойство, добавленное через `prototype`, для одного экземпляра, оно не изменится для других. При присваивании значения свойству, которое изначально было унаследовано от прототипа, это свойство создается непосредственно в самом объекте-экземпляре, "затеняя" унаследованное значение, но не перезаписывая его в прототипе для остальных.

11. Изменение встроенных прототипов считается плохой практикой, потому что это может привести к непредсказуемым конфликтам с будущими версиями JavaScript или со сторонними библиотеками, которые могут ожидать стандартного поведения встроенных объектов.
    Это нарушает принцип инкапсуляции и усложняет поддержку кода.

12. Наследованию на основе классов "под капотом" в JavaScript позволяет работать механизм прототипного наследования.
    Классы являются лишь "синтаксическим сахаром" — удобной записью для функций-конструкторов и работы с цепочкой прототипов, которая является фундаментальной для языка.
