# Наследование и Прототипы

Представьте, что вы строите город из Lego. У вас есть общий дизайн для "транспортного средства": у него есть колеса, цвет, и оно может ехать. Вместо того чтобы каждый раз с нуля собирать машину, мотоцикл и лодку, вы сначала создаете базовую модель "транспорта". Затем вы берете эту модель и добавляете к ней новые детали: у машины — крышу и четыре колеса, у мотоцикла — руль и два колеса, у лодки — пропеллер. Этот процесс использования общей основы и создания на ее базе специализированных вариций и называется **наследованием**.

В программировании, и в частности в JavaScript, наследование позволяет нам создавать новые классы на основе существующих. Это экономит время, уменьшает количество ошибок и помогает структурировать код, делая его логичным и понятным.

## Базовый класс: Родитель

Давайте создадим тот самый общий чертеж, родительский класс. В нашем примере это будет класс `Vehicle` (Транспортное средство).

```javascript
class Vehicle {
  constructor(color, currentSpeed, maxSpeed) {
    this.color = color;
    this.currentSpeed = currentSpeed;
    this.maxSpeed = maxSpeed;
  }

  move() {
    console.log(`Движется со скоростью ${this.currentSpeed} км/ч.`);
  }

  accelerate(amount) {
    // Проверяем, не превысит ли ускорение максимальную скорость
    if (this.currentSpeed + amount <= this.maxSpeed) {
      this.currentSpeed += amount;
      console.log(`Ускоряемся на ${amount}. Текущая скорость: ${this.currentSpeed}`);
    } else {
      this.currentSpeed = this.maxSpeed;
      console.log(`Достигнута максимальная скорость: ${this.maxSpeed} км/ч!`);
    }
  }
}
```

Здесь мы определили общие для всего транспорта характеристики (свойства): `color` (цвет), `currentSpeed` (текущая скорость) и `maxSpeed` (максимальная скорость). Также мы описали общие действия (методы): `move()` (двигаться) и `accelerate()` (ускориться).

## Наследование с помощью `extends`: Дочерний класс

Теперь представим, что нам нужен конкретный вид транспорта — мотоцикл. У него есть все те же свойства, что и у общего Vehicle, но также есть что-то уникальное, например, тип топлива (`fuel`) и способность делать "вилли" (езду на заднем колесе). Для этого мы создадим дочерний класс `Motorcycle`, который *наследует* от `Vehicle`.

Ключевое слово `extends` сообщает JavaScript, что класс `Motorcycle` является расширением (потомком) класса `Vehicle`.

```javascript
class Motorcycle extends Vehicle {
  constructor(color, currentSpeed, maxSpeed, fuel) {
    super(color, currentSpeed, maxSpeed); // Вызов конструктора родителя
    this.fuel = fuel; // Добавляем новое уникальное свойство
  }

  doWheelie() {
    console.log("Едем на заднем колесе! Уиии!");
  }
}
```

**Разберем ключевые моменты:**

1.  **`extends Vehicle`**: Эта часть объявления класса означает "Создай класс Motorcycle, который унаследует ВСЕ от класса Vehicle".
2.  **`super(...)`**: Это самая важная часть. Ключевое слово `super` используется для вызова функций, принадлежащих родителю класса.
    - В конструкторе дочернего класса **обязательно** сначала вызвать `super()`, прежде чем использовать ключевое слово `this`. Это нужно для того, чтобы создать базовый "скелет" объекта со свойствами `color`, `currentSpeed` и `maxSpeed`. Без этого JavaScript выдаст ошибку.
    - В `super()` мы передаем параметры, которые ожидает конструктор родительского класса (`Vehicle`).
3.  **Добавление своего**: После вызова `super()` мы спокойно можем добавлять новые свойства, используя `this`, как в обычном конструкторе. Здесь мы добавили `this.fuel = fuel`.
4.  **Новый метод**: Мы также добавили совершенно новый метод `doWheelie()`, которого не было в родительском классе. Это нормально и ожидаемо.

## Используем наш дочерний класс

Теперь давайте посмотрим на магию наследования в действии. Создадим объект (экземпляр) класса `Motorcycle`.

```javascript
// Создаем мотоцикл: цвет черный, текущая скорость 0, макс. скорость 250, топливо - бензин
let myBike = new Motorcycle("черный", 0, 250, "бензин");

// Методы и свойства родительского класса НАСЛЕДУЮТСЯ!
console.log(myBike.color); // Работает! Выведет: "черный"
myBike.accelerate(50);     // Работает! Выведет: "Ускоряемся на 50. Текущая скорость: 50"
myBike.move();             // Работает! Выведет: "Движется со скоростью 50 км/ч."

// И мы можем использовать уникальные методы дочернего класса
myBike.doWheelie();        // Выведет: "Едем на заднем колесе! Уиии!"

// И доступ к уникальному свойству тоже есть
console.log(`Этот мотоцикл заправляется: ${myBike.fuel}`); // Выведет: "Этот мотоцикл заправляется: бензин"
```

**Важное правило:** Наследование работает только в одну сторону — от родителя к потомку. Экземпляр родительского класса `Vehicle` **НЕ** будет иметь доступа к методам и свойствам дочернего класса `Motorcycle`.

```javascript
let genericVehicle = new Vehicle("белый", 50, 150);
genericVehicle.move(); // Это работает.
genericVehicle.doWheelie(); // ОШИБКА! genericVehicle.doWheelie is not a function
```

## Что такое Прототипы? Механика под капотом

Вы могли спросить: "Как именно JavaScript это делает?" Ответ — **прототипы**.

В JavaScript каждый объект имеет скрытое свойство `[[Prototype]]` (к которому можно получить доступ через `__proto__` в браузерах или через методы `Object.getPrototypeOf()`). Это свойство ссылается на другой объект, который называется его "прототипом".

Когда вы пытаетесь прочитать свойство или вызвать метод у объекта (например, `myBike.move()`), JavaScript сначала ищет это свойство/метод в самом объекте. Если он его не находит, он ищет в его прототипе (`[[Prototype]]`). Если не находит и там, он идет по цепочке прототипов выше, пока не найдет его или не достигнет конца цепочки (объекта `null`).

Классы в JavaScript — это лишь "синтаксический сахар", удобная надстройка над этой системой прототипов. Когда мы пишем `class Motorcycle extends Vehicle`, мы по сути говорим: "Сделай так, чтобы `[[Prototype]]` объекта `Motorcycle` указывал на `Vehicle.prototype`".

## Как использовать `prototype` для расширения классов

У каждой функции-класса есть специальное свойство `.prototype`. Методы, которые мы объявляем внутри класса (как `move()` или `accelerate()`), автоматически записываются в этот объект `Vehicle.prototype`.

Мы можем вручную добавлять новые методы или даже свойства в этот `prototype`, и тогда они станут доступны всем экземплярам этого класса (и его потомков!), даже тем, которые были созданы *до* добавления метода.

**Вернемся к нашему классу `Person` из примера:**

```javascript
class Person {
  constructor(firstname, lastname) {
    this.firstname = firstname;
    this.lastname = lastname;
  }
  greet() {
    console.log("Привет!");
  }
}

// Добавим новый метод через prototype
Person.prototype.introduce = function () {
  console.log(`Привет, меня зовут ${this.firstname}`);
};

// Добавим свойство через prototype (менее распространено)
Person.prototype.favoriteColor = "зеленый";

// Теперь используем это
let person1 = new Person("Мария", "Сага");
let person2 = new Person("Иван", "Петров");

person1.introduce(); // Выведет: "Привет, меня зовут Мария"
console.log(person2.favoriteColor); // Выведет: "зеленый"

// Мы можем переопределить свойство для конкретного объекта
person2.favoriteColor = "синий";
console.log(person2.favoriteColor); // Выведет: "синий"
console.log(person1.favoriteColor); // Выведет: "зеленый" (оригинальное значение в прототипе не изменилось)
```

**Зачем это нужно?**

- **Расширение встроенных объектов:** Это основной способ добавления новых методов к встроенным классам JavaScript, таким как `Array` или `String` (хотя делать это нужно с большой осторожностью).
- **Модификация классов "извне":** Если у вас нет доступа к исходному коду класса (например, он из сторонней библиотеки), но вы хотите его дополнить, вы можете использовать `prototype`.
- **Важное предупреждение:** Если вы полностью контролируете код класса, всегда лучше изменять его напрямую, а не через `prototype`. И **НИКОГДА** не изменяйте прототипы встроенных JavaScript-объектов (如 `Object.prototype`, `Array.prototype`), так как это может сломать работу всего вашего кода и сторонних библиотек.

## Заключение

1.  **Наследование (`extends` и `super`)** — это мощный инструмент для создания иерархии классов, который помогает избегать дублирования кода.
2.  **Прототипы** — это механизм "под капотом", который делает наследование в JavaScript возможным.
3.  **Используйте наследование для моделирования отношений "is-a" (является)**. Мотоцикл *является* транспортным средством. Это хороший кандидат для наследования. Если отношение больше похоже на "has-a" (имеет), возможно, лучше использовать композицию (создание экземпляра другого класса внутри своего).
4.  **Всегда вызывайте `super()` в конструкторе дочернего класса** до того, как использовать `this`.
5.  **Изменение кода через `prototype`** — это продвинутая техника. Используйте ее в основном для полифилов (эмуляции новых функций в старых браузерах) или для расширения функционала сторонних библиотек, когда нет другого выхода.
