# Ответы по теме "Геттеры и сеттеры"

1. Они предоставляют контролируемый доступ к внутренним данным объекта, предотвращая прямое манипулирование свойствами и позволяя добавлять логику проверки, преобразования или логирования.
   Это обеспечивает целостность данных, как в примере с банковским счетом, где нельзя напрямую изменить баланс, нарушив бизнес-правила.

2. Символ `#` (решетка).
   Приватное свойство `#firstname` объявляется в начале класса, что делает его недоступным для чтения или изменения извне экземпляра этого класса.

3. Потому что приватные свойства, объявленные с помощью `#`, по определению доступны только внутри тела класса.
   Это основное правило работы приватных полей класса, предназначенное для реализации инкапсуляции.

4. Ключевое слово `get`. Пример: `get firstname() { return this.#firstname; }`.
   Ключевое слово `get` ставится перед именем метода, который будет действовать как геттер. Этот метод не принимает параметров.

5. Геттер используется как свойство, без скобок: `console.log(p.firstname);`.
   Синтаксис геттера и сеттера специально разработан так, чтобы имитировать обращение к обычному свойству, а не вызов метода, что делает код чище.

6. Ключевое слово `set`. Пример: `set firstname(newFirstname) { ... }`.
   Ключевое слово `set` ставится перед именем метода, который будет действовать как сеттер. Этот метод принимает один параметр (новое значение).

7. Сеттер используется как свойство, без скобок, с оператором присваивания `=`: `p.firstname = "Anna";`.
   При выполнении этого присваивания автоматически вызывается функция-сеттер, и значение "Anna" передается ей в качестве аргумента.

8. Главное преимущество сеттера — возможность добавить проверку или другую логику (валидацию, трансформацию) перед тем, как значение будет actually присвоено.
   Это предотвращает попадание недопустимых или некорректных данных во внутреннее состояние объекта, защищая его целостность.

9. 1) Проверка типа данных (`typeof newFirstname === 'string'`). 2) Проверка длины строки (`newFirstname.length > 2`).
      Эти проверки гарантируют, что новое значение имени будет строкой и что оно будет иметь осмысленную длину, превышающую 2 символа.

10. Вычисляемое свойство — это значение, которое не хранится в объекте напрямую, а вычисляется динамически на основе других свойств при обращении к нему. Геттер является идеальным механизмом для его создания.
    Геттер позволяет определить функцию для получения значения, которое может быть результатом комбинации или обработки других данных объекта, как `fullName` или `canVote`.

11. `get canVote() { return this.#age >= 18; }`. Оно вычисляется на основе приватного свойства `#age`.
    Значение этого свойства не хранится где-либо, а вычисляется "на лету" каждый раз, когда к нему обращаются, путем проверки условия (возраст >= 18).

12. Сеттер `fullName` принимает строку, разбивает ее по пробелу на части с помощью `split(' ')`, и затем первую часть присваивает `#firstname`, а вторую (если она есть) — `#lastname`.
    Это демонстрирует мощь сеттеров: один акт присваивания (`p.fullName = "Anna Johnson"`) может запустить сложную логику по обновлению нескольких внутренних полей объекта.

13. Да, может. Если есть только геттер — свойство становится read-only (только для чтения). Если есть только сеттер — свойство становится write-only (только для записи), что встречается реже.
    Это дает гибкость в проектировании API объекта. Например, свойство `canVote` имеет только геттер, так как его значение логически выводится из возраста и не должно назначаться вручную.

14. Они скрывают внутреннее состояние объекта (реализованное через приватные свойства) и предоставляют строго контролируемый публичный интерфейс для взаимодействия с этим состоянием.
    Инкапсуляция — это принцип, согласно которому данные объекта и детали их обработки скрыты от внешнего мира, а геттеры/сеттеры являются "воротами" к этим данным.

15. Код с геттерами/сеттерами будет более надежным. Прямой доступ к публичному свойству позволяет установить любое, даже некорректное значение (например, отрицательный возраст). Геттеры и сеттеры позволяют enforce validation rules (накладывать правила валидации).
    Надежность достигается за счет того, что сеттер гарантирует, что в свойство будет установлено только валидное значение, а геттер может гарантировать определенный формат возвращаемых данных.
