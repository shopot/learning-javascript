# Геттеры и сеттеры в JavaScript

## Зачем нужны геттеры и сеттеры?

Представьте, что у вас есть банковский счет. Вы не хотите, чтобы кто-то мог напрямую изменять баланс вашего счета без проверки. Например, нельзя снять больше денег, чем есть на счету, или положить отрицательную сумму.

Геттеры и сеттеры решают именно эту задачу — они предоставляют контролируемый доступ к внутренним данным объекта, позволяя:

- Проверять данные перед их изменением
- Преобразовывать данные перед их возвратом
- Логировать операции с данными
- Вычислять значения на основе других свойств

## Напоминание о приватных свойствах

Как мы узнали ранее, приватные свойства объявляются с помощью символа `#` и недоступны извне класса:

```javascript
class Person {
  #firstname;
  #lastname;

  constructor(firstname, lastname) {
    this.#firstname = firstname;
    this.#lastname = lastname;
  }
}

let p = new Person("Maria", "Saga");
console.log(p.#firstname); // Ошибка!
```

Но как же получить доступ к этим свойствам? Для этого и существуют геттеры и сеттеры.

## Геттеры (get)

Геттеры — это специальные методы, которые позволяют читать значения свойств. Они объявляются с помощью ключевого слова `get` и используются как обычные свойства (без скобок).

```javascript
class Person {
  #firstname;
  #lastname;

  constructor(firstname, lastname) {
    this.#firstname = firstname;
    this.#lastname = lastname;
  }

  // Геттер для firstname
  get firstname() {
    return this.#firstname;
  }

  // Геттер для lastname
  get lastname() {
    return this.#lastname;
  }
}

let p = new Person("Maria", "Saga");
console.log(p.firstname); // "Maria" (работает геттер)
```

**Преимущество геттеров:** мы можем преобразовать данные перед их возвратом. Например, мы можем гарантировать, что имя всегда будет возвращаться с заглавной буквы:

```javascript
get firstname() {
  return this.#firstname.charAt(0).toUpperCase() + this.#firstname.slice(1);
}
```

## Сеттеры (set)

Сеттеры — это специальные методы, которые позволяют изменять значения свойств. Они объявляются с помощью ключевого слова `set` и также используются как свойства.

```javascript
class Person {
  #firstname;
  #lastname;

  constructor(firstname, lastname) {
    this.#firstname = firstname;
    this.#lastname = lastname;
  }

  // Сеттер для firstname с проверкой
  set firstname(newFirstname) {
    if (typeof newFirstname === 'string' && newFirstname.length > 2) {
      this.#firstname = newFirstname;
    } else {
      console.error("Имя должно быть строкой длиннее 2 символов");
    }
  }

  // Геттер для firstname
  get firstname() {
    return this.#firstname;
  }
}

let p = new Person("Maria", "Saga");
p.firstname = "Anna"; // Работает сеттер
console.log(p.firstname); // "Anna"

p.firstname = "A"; // Ошибка: "Имя должно быть строкой длиннее 2 символов"
```

**Сила сеттеров** заключается в возможности проверять и валидировать данные перед их установкой. Мы можем добавить любую логику проверки:

```javascript
set firstname(newFirstname) {
  if (newFirstname.startsWith("M")) {
    this.#firstname = newFirstname;
  } else {
    this.#firstname = "M" + newFirstname;
  }
}
```

## Вычисляемые свойства

Геттеры могут создавать вычисляемые свойства — значения, которые не хранятся непосредственно в объекте, а вычисляются на основе других свойств.

```javascript
class Person {
  #firstname;
  #lastname;

  constructor(firstname, lastname) {
    this.#firstname = firstname;
    this.#lastname = lastname;
  }

  // Вычисляемое свойство - полное имя
  get fullName() {
    return `${this.#firstname} ${this.#lastname}`;
  }

  // Сеттер для fullName позволяет установить обе части имени
  set fullName(name) {
    const parts = name.split(' ');
    this.#firstname = parts[0];
    this.#lastname = parts[1] || '';
  }
}

let p = new Person("Maria", "Saga");
console.log(p.fullName); // "Maria Saga"

p.fullName = "Anna Johnson";
console.log(p.firstname); // "Anna"
console.log(p.lastname); // "Johnson"
```

## Полный пример класса с геттерами и сеттерами

Давайте соберем все вместе в один законченный пример:

```javascript
class Person {
  // Приватные поля
  #firstname;
  #lastname;
  #age;

  constructor(firstname, lastname, age = 0) {
    this.#firstname = firstname;
    this.#lastname = lastname;
    this.#age = age;
  }

  // Геттеры
  get firstname() {
    return this.#firstname;
  }

  get lastname() {
    return this.#lastname;
  }

  get age() {
    return this.#age;
  }

  get fullName() {
    return `${this.#firstname} ${this.#lastname}`;
  }

  get canVote() {
    return this.#age >= 18; // Вычисляемое свойство
  }

  // Сеттеры
  set firstname(value) {
    if (typeof value === 'string' && value.length > 1) {
      this.#firstname = value;
    } else {
      console.error("Имя должно быть строкой длиннее 1 символа");
    }
  }

  set lastname(value) {
    if (typeof value === 'string' && value.length > 1) {
      this.#lastname = value;
    } else {
      console.error("Фамилия должна быть строкой длиннее 1 символа");
    }
  }

  set age(value) {
    if (typeof value === 'number' && value >= 0) {
      this.#age = value;
    } else {
      console.error("Возраст должен быть положительным числом");
    }
  }

  // Метод
  greet() {
    console.log(`Привет! Меня зовут ${this.fullName}`);
  }
}

// Использование
const person = new Person("Иван", "Петров", 25);

console.log(person.firstname); // "Иван"
console.log(person.fullName); // "Иван Петров"
console.log(person.canVote); // true (25 >= 18)

person.age = 30; // Корректное изменение
person.age = -5; // Ошибка: "Возраст должен быть положительным числом"

person.firstname = "П"; // Ошибка: "Имя должно быть строкой длиннее 1 символа"

person.greet(); // "Привет! Меня зовут Иван Петров"
```

## Итоги

- **Геттеры** предоставляют контролируемый доступ для чтения свойств
- **Сеттеры** предоставляют контролируемый доступ для изменения свойств
- **Приватные свойства** защищают данные от прямого доступа извне
- **Вычисляемые свойства** dynamically calculate values based on other properties
- **Инкапсуляция** ensures data integrity by controlling how data is accessed and modified

Геттеры и сеттеры — это мощный механизм, который помогает создавать более надежные и предсказуемые объекты, соответствующие принципам объектно-ориентированного программирования.
