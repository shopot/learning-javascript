# Список ответов по теме "Модули в ES6"

**1.** Ключевые слова `import` и `export`.
Пояснение: Эти ключевые слова добавляют в язык синтаксис для объявления зависимостей (импорт) и для предоставления функциональности другим модулям (экспорт).

**2.** Каждый файл является самостоятельным модулем, а экспортированные значения из одного модуля доступны для импорта в других.
Пояснение: И в ES6, и в Node.js модульная система основана на принципе изоляции файлов-модулей и явного обмена functionality между ними через export/import.

**3.** Константы, переменные, функции и классы, определенные в файле.
Пояснение: Все объявления верхнего уровня в модуле по умолчанию являются приватными и не доступны извне, пока они не будут явно экспортированы с помощью ключевого слова `export`.

**4.** В обычных скриптах объявления попадают в глобальную область видимости, а в модулях каждый файл имеет свой приватный контекст.
Пояснение: Это ключевое отличие, которое предотвращает загрязнение глобального пространства имен и обеспечивает изоляцию кода.

**5.** В строгом режиме (`strict mode`).
Пояснение: Код в модулях автоматически выполняется в строгом режиме, что накладывает дополнительные ограничения и делает код более безопасным и предсказуемым.

**6.** Инструкцию `with`, объект `arguments` и необъявленные переменные.
Пояснение: Эти ограничения накладываются строгим режимом (`strict mode`), который включен по умолчанию для всех модулей ES6.

**7.** `undefined`.
Пояснение: В отличие от обычных скриптов, где `this` на верхнем уровне refers to the global object (например, `window` в браузере), в модулях ES6 это значение равно `undefined`.

**8.** `<script type="module">`.
Пояснение: Атрибут `type="module"` указывает браузеру, что загружаемый скрипт является модулем ES6 и его нужно обрабатывать accordingly (с поддержкой импорта, в строгом режиме и т.д.).

**9.** С версии 13.
Пояснение: Нативная поддержка ES6-модулей в Node.js стала стабильной, начиная с версии 13.

**10.** Добавить ключевое слово `export` перед объявлением константы: `export const MY_CONST = 10;`.
Пояснение: Это именованный экспорт. Ключевое слово `export` делает объявление доступным для импорта из других модулей.

**11.** Использовать один `export` statement в конце модуля со списком экспортируемых идентификаторов в фигурных скобках: `export { value1, value2, ClassName };`.
Пояснение: Такой подход позволяет собрать все экспорты в одном месте модуля, что упрощает чтение и понимание кода.

**12.** Когда модуль экспортирует только одно значение (например, функцию или класс).
Пояснение: `export default` упрощает процесс импорта для потребителя модуля, так как он может присвоить импортируемому значению любое имя.

**13.** Любое выражение, включая анонимные function expressions и анонимные class expressions.
Пояснение: `export default` может экспортировать результат выражения, в то время как именованный экспорт `export` требует объявления с именем.

**14.** Да, это возможно, но встречается нечасто.
Пояснение: Модуль может иметь неограниченное количество именованных экспортов, но только один экспорт по умолчанию.

**15.** Только на верхнем уровне (top-level) модуля.
Пояснение: Нельзя использовать `export` внутри функций, циклов, условий или блоков кода. Это требование необходимо для статического анализа кода.

**16.** С помощью синтаксиса `import AnyName from './module.js';`.
Пояснение: При импорте значения по умолчанию после ключевого слова `import` указывается любое имя, которое будет присвоено импортированному значению.

**17.** С помощью синтаксиса `import { namedValue1, namedValue2 } from './module.js';`.
Пояснение: Имена в фигурных скобках должны точно совпадать с именами именованных экспортов в целевом модуле.

**18.** С помощью синтаксиса `import * as ModuleObject from './module.js';`.
Пояснение: Это импортирует все именованные экспорты модуля и сохраняет их в виде свойств объекта `ModuleObject`. Экспорт по умолчанию (если есть) не попадает в этот объект и должен импортироваться отдельно.

**19.** С помощью синтаксиса `import DefaultImport, { namedImport1, namedImport2 } from './module.js';`.
Пояснение: Первым указывается имя для импорта по умолчанию (без фигурных скобок), а затем, через запятую, перечисляются именованные импорты в фигурных скобках.

**20.** Для выполнения кода модуля, который имеет side effects (например, регистрирует обработчики событий, инициализирует что-либо), но не экспортирует никаких значений.
Пояснение: Такой модуль будет выполнен ровно один раз при первом импорте, даже если он не предоставляет никаких значений для использования в импортирующем модуле.

**21.** Это должна быть строковая константа (в одинарных или двойных кавычках). Это должен быть абсолютный путь, относительный путь (начинающийся с `./` или `../`) или полный URL.
Пояснение: Динамические вычисления путей с помощью переменных или шаблонных строк с интерполяцией не допускаются. Это требование необходимо для возможности статического анализа зависимостей до выполнения кода.

**22.** Потому что это создает неоднозначность: непонятно, является ли такой модуль локальным файлом или модулем из какой-либо системной директории (как в Node.js).
Пояснение: Стандарт ES6 требует явного указания относительности пути для избежания путаницы. Сборщики вроде webpack могут обходить это ограничение благодаря своей конфигурации.

**23.** Использовать ключевое слово `as` для их переименования: `import { render as renderImage } from './image.js'; import { render as renderUI } from './ui.js';`.
Пояснение: Это позволяет создать в текущем модуле уникальные имена для импортируемых значений, избегая конфликта имен.

**24.** Использовать синтаксис `import { default as NewName } from './module.js';`.
Пояснение: Ключевое слово `default` здесь используется как псевдоним для экспорта по умолчанию в целевом модуле, а `as` позволяет присвоить ему новое имя.

**25.** Да, с помощью синтаксиса `export { originalName as exportedName };`.
Пояснение: Это делается в рамках export statement с фигурными скобками. Важно помнить, что это не объектный литерал, а специальный синтаксис.

**26.** Реэкспорт — это импорт значения из одного модуля и его немедленный экспорт из текущего модуля.
Пояснение: Он используется для создания фасадных модулей, которые агрегируют и повторно экспортируют functionality из нескольких других модулей, упрощая структуру зависимостей.

**27.** С помощью синтаксиса `export { someValue } from './other-module.js';`.
Пояснение: Эта строка эквивалентна последовательности `import { someValue } from './other-module.js'; export { someValue };`.

**28.** С помощью синтаксиса `export * from './other-module.js';`.
Пояснение: Эта конструкция реэкспортирует все именованные экспорты из указанного модуля. Важно: экспорт по умолчанию при этом не реэкспортируется.

**29.** С помощью синтаксиса `export { originalName as newName } from './module.js';`.
Пояснение: Это позволяет изменить имя значения при его реэкспорте из текущего модуля.

**30.** С помощью синтаксиса `export { default as namedExport } from './module.js';`.
Пояснение: Эта конструкция импортирует экспорт по умолчанию из целевого модуля и реэкспортирует его из текущего модуля как именованный экспорт с указанным именем.

**31.** С помощью синтаксиса `export { namedExport as default } from './module.js';`.
Пояснение: Эта конструкция импортирует именованный экспорт из целевого модуля и реэкспортирует его из текущего модуля как экспорт по умолчанию.

**32.** Изоляция кода, явное указание зависимостей, поддержка статического анализа, автоматический строгий режим, предотвращение загрязнения глобальной области видимости.
Пояснение: Эти преимущества делают код более организованным, предсказуемым, легким для тестирования и поддержки.
