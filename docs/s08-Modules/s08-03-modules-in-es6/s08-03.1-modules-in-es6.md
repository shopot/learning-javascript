# Модули в ES6

Стандарт ES6 ввел в JavaScript ключевые слова `import` и `export`, добавив поддержку модульности как основной языковой функции. Модульность в ES6 концептуально аналогична модульности в Node.js: каждый файл представляет собой самостоятельный модуль, а константы, переменные, функции и классы, определенные в файле, являются приватными для этого модуля, если они не экспортируются явно. Значения, экспортированные из одного модуля, становятся доступными для использования в других модулях, которые их импортируют.

## Отличия модулей от обычных скриптов

Модули ES6 отличаются от обычных JavaScript-скриптов несколькими важными способами:

- **Изоляция контекста**: В обычных скриптах объявления переменных, функций и классов на верхнем уровне попадают в единый глобальный контекст, общий для всех скриптов. В модулях каждый файл имеет собственный приватный контекст.
- **Строгий режим**: Код внутри модуля ES6 автоматически работает в строгом режиме. Вам больше не нужно писать `"use strict"`.
- **Ограничения**: Код в модулях не может использовать инструкцию `with`, объект `arguments` или необъявленные переменные.
- **Значение `this`**: На верхнем уровне модуля `this` имеет значение `undefined` (в отличие от скриптов, где `this` ссылается на глобальный объект).

## Модули ES6 в браузере и Node.js

Модули ES6 уже несколько лет используются в вебе с помощью сборщиков кода (например, webpack), которые объединяют отдельные модули в большие бандлы для включения в веб-страницы. Все современные браузеры (кроме Internet Explorer) поддерживают модули ES6 нативно. Для их использования в HTML добавляется специальный тег:

```html
<script type="module" src="module.js"></script>
```

В Node.js ситуация сложнее: необходимо поддерживать две не совсем совместимые модульные системы. Начиная с версии 13, Node.js поддерживает ES6-модули, но большинство существующих программ все еще используют модули Node.js.

## Экспорт из модулей

### Именованный экспорт

Чтобы экспортировать константу, переменную, функцию или класс из модуля ES6, добавьте ключевое слово `export` перед объявлением:

```javascript
export const PI = Math.PI;

export function degreesToRadians(d) {
  return d * PI / 180;
}

export class Circle {
  constructor(r) {
    this.r = r;
  }
  
  area() {
    return PI * this.r * this.r;
  }
}
```

Альтернативный подход: можно определить все элементы обычным образом, а затем в конце модуля экспортировать их списком:

```javascript
export { Circle, degreesToRadians, PI };
```

Фигурные скобки в этом случае не являются объектным литералом — это специальный синтаксис для списка идентификаторов.

### Экспорт по умолчанию

Если модуль экспортирует только одно значение (обычно функцию или класс), рекомендуется использовать `export default`:

```javascript
export default class BitSet {
  // реализация
}
```

Экспорт по умолчанию упрощает импорт в других модулях. В отличие от обычного экспорта, `export default` может экспортировать любое выражение, включая анонимные функции и классы.

Модуль может содержать как именованные экспорты, так и экспорт по умолчанию, хотя это встречается нечасто.

### Ограничения экспорта

Ключевое слово `export` может использоваться только на верхнем уровне модуля. Нельзя экспортировать значения изнутри классов, функций, циклов или условий. Это важно для статического анализа: экспорт модуля одинаков при каждом запуске, и символы можно определить до выполнения модуля.

## Импорт значений

### Импорт экспорта по умолчанию

Для импорта значения, экспортированного по умолчанию:

```javascript
import BitSet from './bitset.js';
```

Идентификатор, к которому привязывается импортируемое значение, является константой. Как и экспорт, импорт может находиться только на верхнем уровне модуля.

### Импорт именованных экспортов

Для импорта конкретных именованных значений из модуля:

```javascript
import { mean, stddev } from "./stats.js";
```

Идентификаторы в фигурных скобках "всплывают" (hoisted) в начало модуля и ведут себя как константы.

### Импорт всего модуля

Чтобы импортировать все именованные экспорты модуля:

```javascript
import * as stats from "./stats.js";
```

Это создает объект `stats`, в котором каждое свойство соответствует одному экспорту модуля. Функции вызываются как `stats.mean()` и `stats.stddev()`.

### Смешанный импорт

Если модуль содержит и экспорт по умолчанию, и именованные экспорты:

```javascript
import Histogram, { mean, stddev } from "./histogram-stats.js";
```

### Импорт без привязки

Если модуль не экспортирует значений, но должен быть выполнен:

```javascript
import "./analytics.js";
```

Такой модуль выполняется при первом импорте. Последующие импорты ничего не делают.

## Спецификация модулей

Модуль указывается строковым литералом в одинарных или двойных кавычках. В браузерах это интерпретируется как URL относительно location импортирующего модуля.

Спецификатор модуля должен быть:
- Абсолютным путем, начинающимся с `/`
- Относительным путем, начинающимся с `./` или `../`
- Полным URL с протоколом и именем хоста

"Голые" спецификаторы модулей (например, `"util.js"`) не допускаются стандартом. Всегда используйте явные указания относительного пути: `"./util.js"`.

## Переименование при импорте и экспорте

### Переименование при импорте

Если нужно импортировать значения с одинаковыми именами из разных модулей:

```javascript
import { render as renderImage } from "./imageutils.js";
import { render as renderUI } from "./ui.js";
```

### Переименование экспорта по умолчанию

Для импорта и переименования экспорта по умолчанию вместе с именованными экспортами:

```javascript
import { default as Histogram, mean, stddev } from "./histogram-stats.js";
```

### Переименование при экспорте

Можно переименовывать значения при экспорте:

```javascript
export {
  layout as calculateLayout,
  render as renderLayout
};
```

Обратите внимание: перед `as` должен быть идентификатор, а не выражение.

## Реэкспорт

Реэкспорт позволяет импортировать значения из других модулей и сразу экспортировать их.

### Простой реэкспорт

```javascript
export { mean } from "./stats/mean.js";
export { stddev } from "./stats/stddev.js";
```

### Реэкспорт всех значений

```javascript
export * from "./stats/mean.js";
export * from "./stats/stddev.js";
```

### Реэкспорт с переименованием

```javascript
export { mean, mean as average } from "./stats/mean.js";
```

### Реэкспорт экспорта по умолчанию

Если импортируемый модуль использует `export default`:

```javascript
export { default as mean } from "./stats/mean.js";
```

### Реэкспорт именованного экспорта как значения по умолчанию

```javascript
export { mean as default } from "./stats.js";
```

### Реэкспорт экспорта по умолчанию как значения по умолчанию

```javascript
export { default } from "./stats/mean.js";
```

## Заключение

Модули ES6 предоставляют мощную систему для организации кода, изоляции областей видимости и управления зависимостями. Понимание различных способов импорта и экспорта необходимо для создания хорошо структурированных и поддерживаемых JavaScript-приложений.

Ключевые преимущества модулей:

- Изоляция кода и предотвращение загрязнения глобальной области видимости
- Явное указание зависимостей
- Поддержка статического анализа
- Автоматический строгий режим
