# Модули в Web

## Нативная поддержка в браузерах

Хотя инструменты сборки могут быть полезны в продакшене, они больше не требуются в процессе разработки, поскольку все современные браузеры обеспечивают нативную поддержку модулей JavaScript.

Важные особенности модулей:
- Они используют строгий режим (strict mode) по умолчанию
- Ключевое слово `this` не ссылается на глобальный объект
- Верхнеуровневые объявления не являются глобальными по умолчанию

## Использование модулей в HTML

Поскольку модули должны выполняться иначе, чем традиционный немодульный код, их использование требует изменений как в JavaScript, так и в HTML. Чтобы нативно использовать директивы `import` в браузере, вы должны указать браузеру, что ваш код является модулем, с помощью тега `<script type="module">`.

## Особенности загрузки модулей

Одной из приятных особенностей модулей ES6 является то, что каждый модуль имеет статический набор импортов. Браузер может загрузить начальный модуль, затем все импортированные им модули, затем модули, импортированные этими модулями, и так далее, пока не будет загружена вся программа.

Спецификатор модуля в инструкции `import` обрабатывается как относительный URL. Тег `<script type="module">` отмечает начальную точку модульной программы.

Пример простого использования:
```html
<script type="module">import "./main.js";</script>
```

## Особенности inline-модулей

Код внутри inline-тега `<script type="module">` является ES6-модулем и может использовать инструкцию `export`. Однако это бессмысленно, поскольку синтаксис HTML тега `<script>` не предоставляет способа определения имени для inline-модулей, поэтому даже если такой модуль экспортирует значение, другой модуль не сможет его импортировать.

## Загрузка и выполнение модулей

Скрипты с атрибутом `type="module"` загружаются и выполняются как скрипты с атрибутом `defer`:
- Загрузка кода начинается, когда HTML-парсер встречает тег `<script>`
- Выполнение кода начинается только после завершения HTML-парсинга
- Скрипты выполняются в порядке их появления в HTML-документе

## Атрибут async для модулей

Вы можете изменить время выполнения модулей с помощью атрибута `async`, который работает для модулей так же, как и для обычных скриптов. Async-модуль выполняется сразу после загрузки кода, даже если HTML-парсинг не завершен, что может изменить относительный порядок выполнения скриптов.

## Обеспечение обратной совместимости

Браузеры, которые поддерживают `<script type="module">`, также должны поддерживать `<script nomodule>`. Браузеры, поддерживающие модули, игнорируют любые скрипты с атрибутом `nomodule` и не выполняют их. Браузеры без поддержки модулей не распознают атрибут `nomodule`, поэтому проигнорируют его и выполнят скрипт.

Это предоставляет мощный инструмент для решения проблем совместимости с браузерами. Браузеры, поддерживающие ES6-модули, также поддерживают другие современные возможности JavaScript, такие как классы, стрелочные функции и цикл `for/of`.

## Кросс-доменная загрузка модулей

Важное отличие обычных скриптов от модульных скриптов связано с кросс-доменной загрузкой. Обычный тег `<script>` загружает файл JavaScript-кода с любого сервера в интернете. Однако `<script type="module">` позволяет ужесточить это правило: модули могут загружаться только из того же источника, что и содержащий HTML-документ, или при наличии правильных CORS-заголовков, разрешающих кросс-доменную загрузку.

К сожалению, это новое ограничение безопасности затрудняет тестирование ES6-модулей в режиме разработки с использованием URL file://. При работе с ES6-модулями вам, вероятно, потребуется настроить статический веб-сервер для тестирования.

## Расширения файлов .mjs

Некоторые программисты используют расширение `.mjs` для区分 модульных JavaScript-файлов от обычных немодульных файлов с традиционным расширением `.js`. Для веб-браузеров и тегов `<script>` расширение файла фактически не имеет значения (хотя важен MIME-тип).

Однако Node.js использует расширение файла как подсказку для определения системы модулей, используемой каждым загружаемым файлом. Поэтому если вы пишете ES6-модули и хотите, чтобы их можно было использовать с Node, может быть полезно adopted соглашение об именовании `.mjs`.

## Динамический импорт с import()

Директивы ES6 `import` и `export` полностью статичны, что позволяет JavaScript-интерпретаторам и другим инструментам определять отношения между модулями с помощью простого анализа текста во время загрузки модулей без необходимости фактического выполнения кода.

Статический импорт гарантирует, что импортируемые значения будут готовы к использованию до начала выполнения кода модуля.

Однако в веб-среде код должен передаваться по сети, а не считываться из файловой системы, и часто выполняется на мобильных устройствах с относительно медленными процессорами. В такой среде статический импорт модулей, требующий загрузки всей программы перед ее выполнением, не всегда оптимален.

## Практика динамической загрузки в веб-приложениях

Обычно веб-приложения initially загружают только enough кода для отображения первой страницы. Затем, когда пользователь получает preliminary контент для взаимодействия, приложение начинает загружать often much larger объем кода, необходимого для остальной части веб-приложения.

## Синтаксис import()

Динамический импорт представлен в ES2020 (по состоянию на начало 2020 года он поддерживается всеми браузерами, поддерживающими ES6-модули). Вы передаете спецификатор модуля в `import()`, и он возвращает объект Promise, представляющий асинхронный процесс загрузки и выполнения указанного модуля.

Пример статического импорта:
```javascript
import * as stats from "./stats.js";
```

Пример динамического импорта:
```javascript
import("./stats.js").then(stats => {
  let average = stats.mean(data);
});
```

В асинхронной функции можно использовать `await` для упрощения кода:
```javascript
async analyzeData(data) {
  let stats = await import("./stats.js");
  return {
    average: stats.mean(data),
    stddev: stats.stddev(data)
  };
}
```

## Важные особенности import()

Аргумент `import()` должен быть спецификатором модуля, как в статической директиве `import`, но может быть любым выражением, evaluating в строку proper формы.

Важно отметить, что `import()` выглядит как вызов функции, но на самом деле является оператором. Круглые скобки являются обязательной частью синтаксиса оператора. Это связано с тем, что `import()` должен иметь возможность разрешать спецификаторы модулей как URL относительно текущего выполняемого модуля, что требует определенной магии реализации, которая не может быть реализована в JavaScript-функции.

## Применение динамического импорта

Динамический `import()` полезен не только в веб-браузерах. Инструменты для сборки кода, такие как webpack, также могут эффективно его использовать. Стратегическое использование вызовов динамического импорта позволяет разбить monolith сборку на набор smaller сборок, которые можно загружать по требованию.

## Метаданные модуля с import.meta

Внутри ES6-модуля (но не внутри обычного тега `<script>` или Node-модуля, загруженного с помощью `require()`) специальный синтаксис `import.meta` ссылается на объект, содержащий метаданные о текущем выполняемом модуле. Свойство `url` этого объекта представляет собой URL, из которого был загружен модуль.

Основной use case `import.meta.url` — возможность ссылаться на изображения, файлы данных или другие ресурсы, хранящиеся в том же каталоге, что и модуль (или относительно него). Конструктор URL() упрощает разрешение относительного URL относительно абсолютного URL, такого как `import.meta.url`.

Пример использования:
```javascript
function localStringsURL(locale) {
  return new URL(`l10n/${locale}.json`, import.meta.url);
}
```
