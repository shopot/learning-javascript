# Список ответов по теме "Асинхронные итераторы и генераторы"

1. Асинхронная итерация — это механизм для работы с последовательностями асинхронных событий или данных. Она решает проблемы обработки потоковых данных, событий и повторяющихся асинхронных операций, с которыми обычные Promise не справляются.

2. Цикл for/await ожидает разрешения Promise перед каждой итерацией, а for/of работает синхронно и не ожидает асинхронных операций.

3. Для асинхронно итерируемых объектов используется Symbol.asyncIterator вместо Symbol.iterator.

4. Метод next() асинхронного итератора возвращает Promise, который разрешается в объект { value, done }, тогда как обычный итератор возвращает такой объект напрямую.

5. Асинхронный генератор объявляется как async function* и сочетает ключевые слова async (для await) и function* (для yield).

6. Promise-обертка для setTimeout создается через new Promise:
   function elapsedTime(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

7. Реализация без генератора обеспечивает более точные временные интервалы, учитывая время выполнения тела цикла, и предотвращает одновременное разрешение нескольких Promise.

8. AsyncQueue — это класс для управления очередью асинхронных значений, который полезен для обработки событий, потоков данных и ситуаций, где значения могут поступать раньше, чем запрашиваются.

9. Для标记 конца потока в AsyncQueue используется специальный символ AsyncQueue.EOS = Symbol("end-of-stream").

10. Для обработки событий браузера создается AsyncQueue, в который события помещаются через addEventListener, а затем итерируются через for/await.

11. Практические применения: обработка файловых потоков, сетевых данных, пользовательских событий, таймеров, WebSockets и любых последовательных асинхронных данных.

12. Обычные Promise предназначены для единичных асинхронных операций, а не для потоков событий, где данные поступают多次но и неупорядоченно.

13. Цикл for/await при работе с массивом Promise ожидает каждый Promise последовательно, выполняя итерации по мере их разрешения.

14. Асинхронные итераторы возвращают Promise для каждого значения, а обычные — значения напрямую; for/await может работать с обоими, но предпочитает асинхронные.

15. Метод close() помечает очередь как закрытую, разрешает все ожидающие Promise значением EOS и останавливает цикл for/await.
