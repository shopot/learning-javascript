# Функции обратного вызова

Добро пожаловать на новый уровень! Если раньше мы заставляли наш код выполняться строго шаг за шагом, то теперь пришло время научиться делать несколько дел одновременно. Это не магия, а мощный инструмент современного JavaScript — **параллелизм** (или многозадачность).

Не пугайтесь, если сначала концепция покажется сложной. Вы переходите от написания простых скриптов к созданию по-настоящему эффективных и умных программ. Это ключевой навык для любого JavaScript-разработчика.

Сегодня мы разберем первый и фундаментальный кирпичик этого подхода — **функции обратного вызова (callback functions)**.

## Зачем нужен параллелизм? Жизненная аналогия

Представьте обычный вечер после работы: нужно приготовить ужин, постирать белье и помыть посуду.

- **Синхронный (последовательный) подход:** Сначала вы ставите пиццу в духовку и **40 минут ждете** у дверцы, пока она приготовится. Только потом идете загружать стиральную машину и **ждете час**, пока закончится стирка. И лишь после этого моете посуду. Вечер затянется надолго!
- **Асинхронный (параллельный) подход:** Вы ставите пиццу в духовку (**запускаете процесс**), но не ждете. Пока она готовится, вы идете загружать стиральную машину и включаете ее (**запускаете следующий процесс**). Пока стирается белье и готовится ужин, вы моете посуду. Вы не ждете завершения одного процесса, чтобы начать другой, а действуете в промежутках. Задачи выполняются "одновременно", и вы справляетесь гораздо быстрее.

Точно так же и ваш код. Без параллелизма он не мог бы, например, загружать новые данные с сервера, не замораживая при этом интерфейс, за которым вы работаете.

## Что такое функция обратного вызова (Callback)?

Проще всего представить себе это так: **"вызови меня потом, когда закончишь"**.

**Функция обратного вызова** — это не особый вид функции. Это любая функция, которая передается как аргумент в другую функцию с ожиданием, что она будет вызвана ("call back" — перезвонить, вызвать обратно) в нужный момент, когда задача будет завершена.

Давайте посмотрим на самый простой пример.

### Базовый синтаксис

```javascript
// 1. Создаем функцию, которая ожидает колбэк
function doSomething(callback) {
  // Какая-то работа...
  console.log("Задача выполнена!");

  // Теперь вызываем функцию, которую нам передали
  callback();
}

// 2. Создаем функцию, которую будем передавать
function sayHi() {
  console.log("Привет!");
}

// 3. Передаем функцию sayHi в качестве аргумента
// Обратите внимание: скобки после sayHi не ставим!
// Мы передаем ссылку на функцию, а не вызываем ее немедленно.
doSomething(sayHi); 

// В консоли будет:
// "Задача выполнена!"
// "Привет!"
```

Пока это выглядит как очень сложный способ вывести `"Привет!"`. Давайте рассмотрим более практичный пример.

## Практический пример с колбэком

Допустим, у нас есть функция, которая вычисляет оценку по баллам, и мы хотим, чтобы результат можно было обработать разными способами (вывести в консоль, отправить на почту, показать на сайте).

```javascript
// Функция-обработчик результата
function showResult(grade) {
  switch (grade) {
    case "A":
      console.log(`Вы получили ${grade}: Отлично!`);
      break;
    case "B":
      console.log(`Вы получили ${grade}: Хорошо!`);
      break;
    case "C":
      console.log(`Вы получили ${grade}: Нормально.`);
      break;
    case "D":
      console.log(`Вы получили ${grade}: Можно и лучше.`);
      break;
    default:
      console.log(`${grade}?! Это провал.`);
  }
}

// Основная функция, принимающая колбэк
function getGrade(score, callback) {
  let grade;

  if (score >= 90) grade = "A";
  else if (score >= 80) grade = "B";
  else if (score >= 70) grade = "C";
  else if (score >= 60) grade = "D";
  else grade = "F";

  // Вместо того чтобы просто возвращать значение,
  // мы "перезваниваем" (call back) и передаем результат в переданную функцию
  callback(grade);
}

// Используем: передаем баллы и функцию-обработчик
getGrade(85, showResult); // Выведет: "Вы получили B: Хорошо!"
```

**В чем здесь мощь?** Мы отделили логику вычисления оценки (`getGrade`) от логики ее отображения (`showResult`). Завтра, если мы захотим не выводить оценку в консоль, а показывать ее во всплывающем окне на веб-странице, нам нужно будет просто написать новую функцию (например, `showPopup`) и передать ее в `getGrade`:

```javascript
getGrade(85, showPopup); // Функция getGrade осталась неизменной!
```

## Колбэки в асинхронных операциях

Истинная сила колбэков раскрывается в асинхронных операциях — когда нужно подождать ответ от сервера, считать файл с диска или просто выполнить код с задержкой.

Классические встроенные функции `setTimeout()` и `setInterval()` — яркие примеры использования колбэков.

```javascript
// setTimeout принимает функцию-колбэк и время задержки
setTimeout(function() {
  console.log("Это сообщение появилось через 2 секунды!");
}, 2000);

// Более чистый вариант с именованной функцией
function encourage() {
  console.log("У тебя все получается, продолжай в том же духе!");
}

// Передаем encourage как колбэк
setInterval(encourage, 1000); // Сообщение будет появляться каждую секунду
```

В этих примерах колбэк не вызывается немедленно. Он регистрируется и вызывается системой **позже**, когда таймер истечет.

## Темная сторона: Ад обратных вызовов (Callback Hell)

Колбэки — отличная концепция, но у них есть серьезный недостаток. Представьте, что ваша задача состоит из нескольких асинхронных шагов, каждый из которых зависит от результата предыдущего.

Например: 1) Получить данные пользователя, 2) потом получить его последний заказ, 3) потом получить список товаров из этого заказа.

Код начинает превращаться в матрешку:

```javascript
getUserData(function(user) {
  getLastOrder(user.id, function(order) {
    getOrderItems(order.id, function(items) {
      calculateTotal(items, function(total) {
        renderInvoice(total, function() {
          console.log("Наконец-то все завершено!");
        });
      });
    });
  });
});
```

Это и есть **"Ад обратных вызовов" (Callback Hell)** или **"Проблема рождественской елки"** (из-за обилия отступов код становится похож на елку). Такой код очень сложно:
- **Читать** и понимать.
- **Отлаживать**.
- **Обслуживать** и изменять.

Из-за этих проблем простые колбэки перестали быть предпочтительным способом работы с асинхронностью. На смену им пришли **Промисы (Promises)** и **async/await**, которые мы изучим в следующих статьях. Они позволяют писать асинхронный код так, будто он синхронный, избавляя нас от "ада".

## Итоги

- **Параллелизм** позволяет вашему коду выполнять несколько операций "одновременно", не блокируя основной поток.
- **Функция обратного вызова (Callback)** — это функция, переданная в качестве аргумента в другую функцию, с ожиданием, что она будет вызвана по завершению какой-либо задачи.
- Колбэки идеально подходят для обработки **асинхронных операций** (ожидание таймера, ответа сервера и т.д.).
- Главный недостаток глубоко вложенных колбэков — **Callback Hell**, который делает код нечитаемым.

Функции обратного вызова — это основа, фундамент асинхронного JavaScript. Поняв их, вы сделали огромный шаг вперед. В следующей статье мы посмотрим, как современный JavaScript решил проблему "ада" с помощью элегантных **Промисов**.

**Задание для закрепления:** Напишите функцию `processData(data, callback)`, которая принимает любые данные (например, строку) и функцию-колбэк. Ваша функция должна преобразовать данные в верхний регистр (используйте `data.toUpperCase()`) и затем передать результат в колбэк.
