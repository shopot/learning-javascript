# Список ответов по теме "Event Loop"

1.  Однопоточная природа JavaScript означает, что в один момент времени может выполняться только одна операция. Пример из статьи: один повар на кухне, который не может начать готовить кофе, пока не закончит готовить пиццу, что привело бы к долгому ожиданию.
2.  Event Loop решает проблему блокировки интерфейса, вызванную однопоточностью, позволяя обрабатывать асинхронные операции без остановки выполнения основного кода.
3.  Call Stack (Стэк вызовов) — это структура данных, которая работает по принципу LIFO (Last In, First Out — последним пришел, первым ушел).
4.  Heap (Куча) — это неструктурированная область памяти, где хранятся объекты, переменные и все данные, которые нужны программе. Call Stack хранит лишь ссылки на эти объекты.
5.  Web APIs — это функции, предоставляемые браузером или средой выполнения (например, Node.js), а не самим JavaScript. Примеры: `setTimeout`, DOM-события, `fetch`, `XMLHttpRequest`.
6.  После обработки Web APIs колбэки попадают в Callback Queue (Очередь колбэков), также известную как Macrotask Queue (Очередь макрозадач).
7.  Основная задача Event Loop — постоянно проверять, пуст ли Call Stack, и если пуст, перемещать задачи из очереди колбэков в Call Stack для выполнения.
8.  Разница в приоритете выполнения: микрозадачи выполняются сразу после текущего синхронного кода и до макрозадач и рендеринга, а макрозадачи — после.
9.  К микрозадачам относятся: колбэки промисов (`.then`, `.catch`, `.finally`), `async/await`, `queueMicrotask()`, `MutationObserver`.
10. К макрозадачам относятся: `setTimeout`, `setInterval`, `setImmediate` (Node.js), обработчики событий (click, scroll и т.д.), `requestAnimationFrame`, I/O операции.
11. Микрозадачи имеют более высокий приоритет выполнения. Они выполняются сразу после синхронного кода и перед любой макрозадачей.
12. После выполнения всего синхронного кода Event Loop сначала полностью очищает очередь микрозадач, затем может произойти рендеринг, и только после этого выполняется первая макрозадача из очереди.
13. setTimeout с задержкой 0 не выполняется мгновенно, потому что его колбэк попадает в очередь макрозадач и будет выполнен только после очистки Call Stack от текущего синхронного кода и всей очереди микрозадач.
14. setTimeout можно использовать для разбиения тяжелой задачи, планируя следующую часть задачи как новую макрозадачу. Это позволяет Event Loop обработать другие события (клики, рендеринг) между итерациями, предотвращая блокировку.
15. Порядок вывода: сначала весь синхронный `console.log`, затем все микрозадачи (колбэки промисов), и только потом макрозадачи (`setTimeout`). Пример: 'Старт', 'Конец', 'Промис 1', 'Промис 2', 'setTimeout'.
16. Для прямой постановки задачи в очередь микрозадач используется функция `queueMicrotask(function)`.
17. Это правило означает, что Event Loop не перейдет к выполнению следующей макрозадачи или рендерингу, пока очередь микрозадач не будет полностью пуста, даже если новые микрозадачи добавляются в процессе выполнения.
18. Event Loop связан с рендерингом тем, что браузер может выполнить перерисовку страницы после выполнения всех микрозадач и перед выполнением следующей макрозадачи.
19. Колбэк setTimeout не может выполниться сразу после истечения таймера, потому что он ждет, пока Call Stack полностью очистится от текущего выполняемого синхронного кода и всех микрозадач.
20. Основные компоненты и их приоритеты: Call Stack (наивысший), Web APIs (вне потока), MicroTask Queue (высокий), MacroTask Queue (низкий), Event Loop (связующее звено).
