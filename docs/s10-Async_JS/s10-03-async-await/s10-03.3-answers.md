# Список ответов для раздела "async/await"

1.  Главную проблему, которую решают операторы `async/await`, — это сложность чтения и поддержки асинхронного кода, основанного на цепочках методов `.then()` и `.catch()` (так называемый "ад колбэков" второго уровня). Они позволяют писать асинхронный код, который выглядит и ведёт себя как синхронный, что делает его интуитивно понятным.

2.  Если обычную функцию, возвращающую число, объявить с помощью `async`, она всегда будет возвращать промис. Этот промис будет автоматически разрешён (fulfilled) с тем значением, которое возвращает оператор return в теле функции. Таким образом, функция вернёт не число, а объект `Promise { 42 }`.

3.  Ключевое слово `await` можно использовать только внутри функций, объявленных с помощью `async`. Его использование вне async-функции вызовет синтаксическую ошибку (SyntaxError), и код не выполнится.

4.  Когда движок JavaScript встречает `await`, он приостанавливает выполнение текущей асинхронной функции до тех пор, пока промис, который стоит после `await`, не будет разрешён или отклонён. Важно отметить, что он не "замораживает" весь браузер или приложение, а лишь приостанавливает функцию, позволяя в это время выполняться другому коду (например, обработчикам событий).

5.  Для обработки ошибок в async-функции используется конструкция `try...catch`. Код, который может выбросить ошибку (все операции с `await`), помещается в блок `try`. Если промис будет отклонён (rejected), выполнение сразу перейдёт в блок `catch`, где можно обработать ошибку. Это делает обработку ошибок в асинхронном коде очень похожей на обработку ошибок в синхронном.

6.  Самая частая ошибка — забыть поставить ключевое слово `await` перед вызовом асинхронной функции. В результате вместо значения, которое должно было быть получено из промиса, в переменную попадёт сам объект промиса в состоянии `<pending>`, и последующий код будет работать некорректно.

7.  Три вызова `talk` выполняются практически одновременно, потому что они запускаются друг за другом без задержки. Каждый вызов запускает функцию `saySomething`, которая стартует свой таймер `setTimeout` почти в один и тот же момент. Все три таймера отсчитывают 2 секунды параллельно, а не последовательно, поэтому их результаты появятся в консоли почти одновременно, примерно через 2 секунды после запуска.

8.  Первый код (`await getA(); await getB();`) выполняет операции последовательно: он ждёт завершения `getA()` и только потом запускает и ждёт `getB()`. Второй код с `Promise.all` запускает оба промиса `getA()` и `getB()` одновременно и ждёт, когда разрешатся оба. Второй подход эффективнее, так как общее время выполнения будет равно времени самого медленного промиса, а не сумме времён выполнения обоих.
