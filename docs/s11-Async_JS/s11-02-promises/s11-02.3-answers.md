# Список ответов для раздела "Промисы"

1. Промис — это специальный объект в JavaScript, который используется для написания асинхронного кода в более структурированном и удобном для обслуживания стиле. Он решает проблему "ада колбэков" — сильной вложенности и сложности чтения асинхронного кода.

2. Промис создается с помощью ключевого слова new и конструктора Promise, который принимает функцию-исполнитель (executor function) с двумя параметрами: `resolve` и `reject`. Например: `new Promise((resolve, reject) => {})`.

3. Функция, передаваемая в конструктор Promise, принимает два параметра: `resolve` и `reject`. Это две callback-функции, которые предоставляет сам JavaScript. Resolve вызывается для успешного завершения промиса, а `reject` — для указания на ошибку.

4. При вызове функции `resolve()` промис переходит в состояние "выполнено" (`fulfilled`). Значение, переданное в `resolve`, становится результатом промиса и передается в первый аргумент метода `then()`.

5. При вызове функции `reject()` промис переходит в состояние "отклонено" (`rejected`). Значение (обычно ошибка или сообщение об ошибке), переданное в `reject`, становится причиной отклонения и передается в метод `catch()` или во второй аргумент `then()`.

6. Успешное выполнение промиса обрабатывается с помощью метода then(), которому передается функция-колбэк. Эта функция выполняется, когда промис переходит в состояние "выполнено", и получает результат работы промиса в качестве аргумента.

7. Ошибка (отклонение) промиса обрабатывается с помощью метода catch(), которому передается функция-колбэк. Этот метод является сокращенной и более читаемой записью для `then(null, errorHandler)` и вызывается при любом отклонении в цепочке промисов.

8. Метод `then()` можно вызывать цепочкой (чейнить) потому, что он всегда возвращает новый промис. Возвращаемое значение из колбэка внутри then становится результатом этого нового промиса, который можно обработать следующим then.

9. Каждый вызов `then()` возвращает совершенно новый промис. Значение, которое возвращается из функции-колбэка внутри `then` (явно через return или неявно — undefined), становится результатом выполнения этого нового промиса и передается в следующий then.

10. Если в цепочке промисов на любом этапе произойдет ошибка (будет вызван `reject` или брошено исключение), выполнение цепочки прервется, и управление перейдет к ближайшему обработчику ошибок — блоку `catch()` или второму аргументу `then()`.

11. Промис может находиться в одном из трех состояний: pending (ожидание), `fulfilled` (выполнено успешно) или `rejected` (выполнено с ошибкой, отклонено). Переход из состояния pending в `fulfilled` или `rejected` является финальным.

12. Нет, состояние завершенного промиса (`fulfilled` или `rejected`) изменить нельзя. Промис является одноразовой конструкцией — после вызова `resolve()` или `reject()` его состояние и результат становятся неизменяемыми.

13. Последовательное выполнение асинхронных операций организуется путем возврата из каждого `then()` нового промиса или значения. Следующий then в цепочке будет ждать разрешения промиса, возвращенного из предыдущего `then`.

14. Главное преимущество промисов перед callback-функциями — это возможность писать асинхронный код в почти линейном, понятном стиле (цепочки then), избегая сильной вложенности ("ада колбэков"), а также централизованная и удобная обработка ошибок через `catch`.

15. Если в промисах будет вызвана функция `reject()` или произойдет ошибка, консоль выведет сообщение об ошибке, переданное в `reject`. Выполнение цепочки then будет прервано, и управление перейдет к блоку `catch()`, который выведет это сообщение. Например, в примере из статьи выведется "oops...".
