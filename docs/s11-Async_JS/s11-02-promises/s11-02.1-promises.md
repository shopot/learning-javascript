# Промисы

## Что такое промисы и зачем они нужны?

Промисы — это специальные объекты в JavaScript, которые позволяют организовать асинхронный код более удобным и читаемым способом. Они представляют собой "обёртку" для значения, которое может быть доступно сейчас или в будущем.

До появления промисов асинхронный код писали с помощью callback-функций (функций обратного вызова), что часто приводило к "аду колбэков" — сложным вложенным структурам, которые было трудно читать и поддерживать. Промисы решают эту проблему, предоставляя более структурированный подход.

Представьте, что вы заказываете пиццу. Официант дает вам устройство, которое загорится и завибрирует, когда пицца будет готова. Это устройство — как промис. Вы можете продолжать общаться с друзьями (выполнять другой код), а когда устройство сработает (промис выполнится), вы получите свою пиццу (результат).

## Создание промиса

Промис создается с помощью конструктора `new Promise()`, который принимает функцию с двумя параметрами: `resolve` и `reject`. Эти параметры являются callback-функциями, которые вы вызываете для указания результата промиса.

```javascript
let promise = new Promise(function(resolve, reject) {
  // Асинхронная операция
  let x = 20;
  
  if (x > 10) {
    resolve(x); // Успешное выполнение
  } else {
    reject("Too low"); // Ошибка
  }
});
```

В этом примере мы сразу знаем значение `x`, но в реальности на этом месте могла бы быть асинхронная операция (запрос к серверу, чтение файла, таймер и т.д.).

## Использование промисов: then и catch

После создания промиса мы можем использовать методы `then()` и `catch()` для обработки результатов.

Метод `then()` принимает две функции (хотя вторую можно опустить):
- Первая функция выполняется при успешном выполнении промиса (когда вызван `resolve()`)
- Вторая функция (необязательная) выполняется при ошибке (когда вызван `reject()`)

```javascript
promise.then(
  function(value) {
    console.log("Success:", value);
  },
  function(error) {
    console.log("Error:", error);
  }
);
```

Более распространённый подход — использование `then()` только для успешного выполнения и `catch()` для обработки ошибок:

```javascript
promise
  .then(function(value) {
    console.log("Success:", value);
  })
  .catch(function(error) {
    console.log("Error:", error);
  });
```

Такой подход считается более читаемым и удобным для построения цепочек.

## Цепочки промисов

Одна из самых мощных возможностей промисов — возможность создавать цепочки вызовов. Каждый метод `then()` возвращает новый промис, который можно использовать для следующего `then()`.

```javascript
const promise = new Promise((resolve, reject) => {
  resolve("success!");
})
.then(value => {
  console.log(value); // "success!"
  return "we";
})
.then(value => {
  console.log(value); // "we"
  return "can";
})
.then(value => {
  console.log(value); // "can"
  return "chain";
})
.then(value => {
  console.log(value); // "chain"
  return "promises";
})
.then(value => {
  console.log(value); // "promises"
})
.catch(error => {
  console.log(error);
});
```

В этом примере каждый `then()` возвращает значение, которое становится аргументом для следующего `then()`. Это позволяет организовывать последовательные асинхронные операции в понятном линейном виде.

## Обработка ошибок в цепочках промисов

Ошибки в цепочках промисов обрабатываются с помощью метода `catch()`. Важная особенность — если ошибка происходит в любом месте цепочки, управление сразу переходит к ближайшему обработчику `catch()`.

```javascript
const promise = new Promise((resolve, reject) => {
  reject("oops... ");
})
.then(value => {
  console.log(value);
  return "we";
})
.then(value => {
  console.log(value);
  return "can";
})
.catch(error => {
  console.log(error); // "oops... "
});
```

В этом примере первый промис отклоняется (reject), поэтому все последующие `then()` пропускаются, и управление сразу передаётся в `catch()`.

## Практический пример: последовательные асинхронные операции

Давайте рассмотрим более практический пример с имитацией асинхронных операций:

```javascript
// Функция, имитирующая асинхронную операцию
function asyncOperation(data, delay) {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (Math.random() > 0.2) { // 80% шанс на успех
        resolve(`Processed: ${data}`);
      } else {
        reject(`Error processing: ${data}`);
      }
    }, delay);
  });
}

// Последовательная обработка
asyncOperation("first", 1000)
  .then(result => {
    console.log(result);
    return asyncOperation("second", 500);
  })
  .then(result => {
    console.log(result);
    return asyncOperation("third", 800);
  })
  .then(result => {
    console.log(result);
    console.log("All operations completed");
  })
  .catch(error => {
    console.error("Something went wrong:", error);
  });
```

В этом примере мы создаем цепочку из трех асинхронных операций, каждая из которых начинается только после успешного завершения предыдущей. Если любая из операций завершится ошибкой, выполнение перейдет к блоку `catch()`.

## Важные особенности промисов

1. **Состояния промиса**:
  - `pending` (ожидание) - начальное состояние
  - `fulfilled` (выполнено) - операция завершена успешно
  - `rejected` (отклонено) - операция завершена с ошибкой

2. **Промисы выполняются сразу при создании** - не нужно вызывать их отдельно.

3. **Промис может быть завершён только один раз** - после вызова `resolve()` или `reject()` последующие вызовы игнорируются.

4. **Цепочки промисов возвращают новый промис** - это позволяет строить длинные цепочки.
