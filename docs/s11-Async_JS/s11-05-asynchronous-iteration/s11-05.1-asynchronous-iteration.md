# Асинхронные итераторы и генераторы

Когда мы работаем с асинхронным кодом в JavaScript, мы часто сталкиваемся с ситуациями, где обычные Promise, async/await и даже генераторы недостаточны. Особенно это касается работы с последовательностями асинхронных событий — такими как клики мыши, потоковые данные или периодические таймеры.

До ES2018 разработчики использовали колбеки и события для обработки таких сценариев. Но с появлением асинхронных итераторов и цикла `for/await` у нас появился элегантный способ работы с асинхронными последовательностями.

## Цикл for/await

Цикл `for/await` — это специальная конструкция, которая позволяет итерировать асинхронные последовательности данных. Он работает с объектами, имеющими метод `[Symbol.asyncIterator]()`.

### Базовый пример с чтением файла

```javascript
const fs = require("fs");

async function parseFile(filename) {
  let stream = fs.createReadStream(filename, { encoding: "utf-8"});
  
  for await (let chunk of stream) {
    console.log(chunk); // Обрабатываем каждую часть данных
  }
}
```

В этом примере цикл `for/await` ожидает каждую порцию данных из файлового потока перед выполнением следующей итерации.

### Работа с массивом Promise

Рассмотрим пример с несколькими URL-адресами:

```javascript
const urls = ['https://api.example.com/data1', 
              'https://api.example.com/data2',
              'https://api.example.com/data3'];

async function fetchAllUrls() {
  const promises = urls.map(url => fetch(url));
  
  // Обычный подход с for/of
  for (const promise of promises) {
    const response = await promise;
    console.log(await response.json());
  }
  
  // Более elegant подход с for/await
  for await (const response of promises) {
    console.log(await response.json());
  }
}
```

Оба поддела делают одно и то же, но `for/await` делает код более читаемым.

## Асинхронные итераторы

Асинхронные итераторы похожи на обычные итераторы, но имеют ключевые отличия:

1. Используют `Symbol.asyncIterator` вместо `Symbol.iterator`
2. Их метод `next()` возвращает Promise, который разрешается в объект результата итерации

### Создание простого асинхронного итератора

```javascript
const asyncIterable = {
  [Symbol.asyncIterator]() {
    let i = 0;
    
    return {
      next() {
        if (i < 5) {
          return Promise.resolve({
            value: i++,
            done: false
          });
        }
        
        return Promise.resolve({
          done: true
        });
      }
    };
  }
};

async function iterate() {
  for await (let value of asyncIterable) {
    console.log(value); // 0, 1, 2, 3, 4
  }
}
```

## Асинхронные генераторы

Асинхронные генераторы объединяют возможности async-функций и генераторов. Они объявляются как `async function*` и используют `await` и `yield` вместе.

### Пример с интервалами

```javascript
// Promise-обертка для setTimeout
function elapsedTime(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

// Асинхронный генератор
async function* clock(interval, max = Infinity) {
  for (let count = 1; count <= max; count++) {
    await elapsedTime(interval); // Ждем указанный интервал
    yield count; // Возвращаем значение
  }
}

// Использование
async function test() {
  for await (let tick of clock(300, 10)) {
    console.log(tick); // 1, 2, 3, ... каждые 300мс
  }
}
```

## Реализация асинхронных итераторов без генераторов

Иногда нам нужно больше контроля, чем предоставляют генераторы. Вот реализация `clock()` без генератора:

```javascript
function clock(interval, max = Infinity) {
  // Promise-версия setTimeout
  function until(time) {
    return new Promise(resolve => setTimeout(resolve, time - Date.now()));
  }
  
  // Возвращаем асинхронно итерируемый объект
  return {
    startTime: Date.now(), // Время начала
    count: 1, // Текущий счетчик
    
    async next() {
      if (this.count > max) {
        return { done: true };
      }
      
      // Вычисляем время для следующей итерации
      let targetTime = this.startTime + this.count * interval;
      await until(targetTime); // Ждем нужное время
      
      return { value: this.count++ };
    },
    
    // Метод, делающий объект итерируемым
    [Symbol.asyncIterator]() { return this; }
  };
}
```

Этот подход обеспечивает более точные интервалы, учитывая время выполнения тела цикла.

## Класс AsyncQueue для сложных сценариев

Для работы с событиями и потоками данных полезно иметь очередь, которая может хранить как значения, так и ожидающие Promise.

```javascript
class AsyncQueue {
  constructor() {
    this.values = []; // Очередь значений
    this.resolvers = []; // Очередь резолверов
    this.closed = false; // Флаг закрытия
  }
  
  enqueue(value) {
    if (this.closed) {
      throw new Error("AsyncQueue closed");
    }
    
    if (this.resolvers.length > 0) {
      // Если есть ожидающие Promise, резолвим первый
      const resolve = this.resolvers.shift();
      resolve(value);
    } else {
      // Иначе добавляем значение в очередь
      this.values.push(value);
    }
  }
  
  dequeue() {
    if (this.values.length > 0) {
      // Если есть значения, возвращаем Promise с значением
      const value = this.values.shift();
      return Promise.resolve(value);
    } else if (this.closed) {
      // Если очередь закрыта, возвращаем EOS
      return Promise.resolve(AsyncQueue.EOS);
    } else {
      // Иначе создаем новый Promise и сохраняем резолвер
      return new Promise((resolve) => { 
        this.resolvers.push(resolve); 
      });
    }
  }
  
  close() {
    // Закрываем очередь и резолвим все ожидающие Promise
    while (this.resolvers.length > 0) {
      this.resolvers.shift()(AsyncQueue.EOS);
    }
    this.closed = true;
  }
  
  [Symbol.asyncIterator]() { return this; }
  
  async next() {
    const value = await this.dequeue();
    return (value === AsyncQueue.EOS)
      ? { done: true }
      : { value: value, done: false };
  }
}

AsyncQueue.EOS = Symbol("end-of-stream"); // Символ конца потока
```

### Использование AsyncQueue для событий браузера

```javascript
function eventStream(element, eventType) {
  const q = new AsyncQueue();
  element.addEventListener(eventType, event => q.enqueue(event));
  return q;
}

async function handleClicks() {
  const clickStream = eventStream(document, "click");
  
  for await (const clickEvent of clickStream) {
    console.log(`Click at: ${clickEvent.clientX}, ${clickEvent.clientY}`);
  }
}
```

## Практические применения

Асинхронная итерация полезна для:
- Обработки потоковых данных (файлы, сетевые соединения)
- Работы с пользовательскими событиями
- Создания таймеров и интервалов с сложной логикой
- Реализации custom-потоков данных

