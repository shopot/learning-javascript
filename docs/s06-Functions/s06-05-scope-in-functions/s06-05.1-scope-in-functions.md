# Область видимости переменных в функциях

**Область видимости (Scope)** — это понятие, которое определяет, где в вашем коде переменная доступна для использования. Грубо говоря, это правила, которые определяют «видимость» переменной. Если переменная находится в области видимости, вы можете её прочитать или изменить. Если она вне области видимости, попытка обратиться к ней приведет к ошибке.

## Локальные переменные в функциях

Локальные переменные — это переменные, объявленные внутри функции. Их жизнь начинается и заканчивается внутри той функции, где они были созданы. Это правило относится к переменным, объявленным с помощью ключевых слов `let` и `var` (их различия мы обсудим чуть позже). Параметры функции, которые не используют `let` или `var`, также являются локальными переменными для этой функции.

Посмотрим на практике, что это значит:

```javascript
function testAvailability(x) { // 'x' — параметр, локальная переменная
  console.log("Available here:", x); // Используем 'x' внутри функции
}
testAvailability("Hi!");
console.log("Not available here:", x); // Пытаемся использовать 'x' снаружи
```

**Результат выполнения:**
```
Available here: Hi!
Uncaught ReferenceError: x is not defined
```

Ошибка `ReferenceError` возникает потому, что переменная `x` существует только внутри функции `testAvailability()`. Как только функция завершила свою работу, переменная `x` уничтожается, и снаружи к ней обратиться невозможно.

То же самое происходит и с переменными, объявленными непосредственно внутри функции:

```javascript
function testAvailability() {
  let y = "Local variable!"; // Объявляем переменную 'y' внутри функции
  console.log("Available here:", y);
}
testAvailability();
console.log("Not available here:", y); // Снова пытаемся использовать 'y' снаружи
```

**Результат выполнения:**
```
Available here: Local variable!
Uncaught ReferenceError: y is not defined
```

Здесь переменная `y` также недоступна за пределами функции, в которой она была объявлена.

### Ключевое слово `return` и локальные переменные

Часто у начинающих возникает вопрос: «Как же получить результат работы функции, если её переменные недоступны?» Ответ — использование оператора `return`.

Важно понимать: `return` возвращает **значение** переменной, а не саму переменную. Вы можете «поймать» это возвращаемое значение и сохранить его в другую переменную уже в другой области видимости.

```javascript
function testAvailability() {
  let y = "I'll return"; // Локальная переменная
  console.log("Available here:", y);
  return y; // Возвращаем ЗНАЧЕНИЕ переменной 'y'
}

let z = testAvailability(); // Сохраняем возвращаемое значение в переменную 'z'
console.log("Outside the function:", z);
console.log("Not available here:", y); // 'y' по-прежнему недоступна здесь
```

**Результат выполнения:**
```
Available here: I'll return
Outside the function: I'll return
Uncaught ReferenceError: y is not defined
```

Обратите внимание: даже though мы вывели значение `I'll return` outside функции, сама переменная `y` осталась недоступной. Мы просто прочитали её значение в момент работы функции и передали его наружу.

## Сравнение переменных `let` и `var`

До появления стандарта ES6 (2015 год) для объявления переменных использовалось только ключевое слово `var`. Теперь у нас есть `let` и `const`. Главное различие между `let` и `var` заключается в том, какую **область видимости** они создают.

*   **`var`** видима в пределах всей функции (**function scope**).
*   **`let`** видима в пределах своего блока кода (**block scope**). Блок кода — это всё, что заключено между фигурными скобками `{ }` (например, внутри `if`, `for`, `while`).

Давайте посмотрим, как это работает.

### Область видимости `var`

```javascript
function doingStuff() {
  if (true) {
    var x = "local"; // Объявляем 'x' через var внутри блока if
  }
  console.log(x); // Обращаемся к 'x' за пределами блока if, но внутри функции
}
doingStuff();
```

**Результат выполнения:**
```
local
```

Переменная `x`, объявленная через `var`, доступна во всей функции `doingStuff()`, несмотря на то, что объявлена она внутри блока `if`. Для `var` фигурные скобки `if` не являются границей.

### Область видимости `let`

Теперь проделаем то же самое с `let`:

```javascript
function doingStuff() {
  if (true) {
    let x = "local"; // Объявляем 'x' через let внутри блока if
  }
  console.log(x); // Пытаемся обратиться к 'x' за пределами её блока
}
doingStuff();
```

**Результат выполнения:**
```
Uncaught ReferenceError: x is not defined
```

Здесь мы получаем ошибку. Переменная `x`, объявленная через `let`, ограничена областью видимости блока `if`. Как только работа кода вышла за закрывающую фигурную скобку `}`, переменная `x` перестала существовать.

### «Поднятие» (Hoisting) переменных

Еще одно важное различие — поведение при обращении к переменной до её объявления.

**Что происходит с `let`?**

```javascript
function doingStuff() {
  if (true) {
    console.log(x); // Пытаемся использовать ДО объявления
    let x = "local";
  }
}
doingStuff();
```

**Результат выполнения:**
```
Uncaught ReferenceError: Cannot access 'x' before initialization
```

JavaScript «видит» объявление `let x` до выполнения кода (поднимает его), но не инициализирует её. Эта зона от начала бока до объявления называется «временной мёртвой зоной». Попытка обратиться к переменной в этой зоне вызовет ошибку.

**Что происходит с `var`?**

```javascript
function doingStuff() {
  if (true) {
    console.log(x); // Используем ДО объявления
    var x = "local";
  }
}
doingStuff();
```

**Результат выполнения:**
```
undefined
```

Здесь ошибки не возникает. Переменная `var` тоже «поднимается», но ей сразу же присваивается значение `undefined`. Такой код выполнится, но почти всегда приведёт к логической ошибке, так как вы ожидаете увидеть `"local"`, а видите `undefined`.

> **Важно:** Тема поднятия (hoisting) глубже, чем кажется. Пока просто запомните правило: всегда объявляйте переменные до их использования. Это избавит вас от проблем и с `let`, и с `var`.

## Область видимости константы (`const`)

Поведение константы, объявленной с помощью `const`, с точки зрения области видимости абсолютно идентично `let`. Её видимость также ограничена блоком.

```javascript
function doingStuff() {
  if (true) {
    const X = "local"; // Константа, объявленная внутри блока
  }
  console.log(X); // Пытаемся обратиться снаружи
}
doingStuff();
```

**Результат выполнения:**
```
Uncaught ReferenceError: X is not defined
```

Попытка использовать `const` до объявления, как и в случае с `let`, выбросит ошибку `ReferenceError`.

## Глобальные переменные

Глобальные переменные — это переменные, объявленные **вне всех функций и блоков кода**, на самом верхнем уровне. Они доступны отовсюду: из любой функции, любого блока — в общем, из любого места вашей программы.

```javascript
let globalVar = "Accessible everywhere!"; // Глобальная переменная

console.log("Outside function:", globalVar);

function creatingNewScope(x) {
  console.log("Access to global vars inside function.", globalVar); // Доступ есть и здесь
}

creatingNewScope("some parameter");
console.log("Still available:", globalVar);
```

**Результат выполнения:**
```
Outside function: Accessible everywhere!
Access to global vars inside function. Accessible everywhere!
Still available: Accessible everywhere!
```

### Сокрытие глобальных переменных

Что произойдет, если внутри функции создать локальную переменную с таким же именем, как у глобальной?

```javascript
let x = "global"; // Глобальная переменная

function doingStuff() {
  let x = "local"; // Локальная переменная с тем же именем
  console.log(x); // Будет использована та, что видна здесь и сейчас
}

doingStuff(); // Вызов функции использует локальную 'x'
console.log(x); // Здесь мы снова в глобальной области видимости
```

**Результат выполнения:**
```
local
global
```

Внутри функции `doingStuff()` локальная переменная `x` «затеняет» (скрывает) глобальную переменную с тем же именем. Когда мы обращаемся к `x` внутри функции, приоритет имеет локальная переменная. При этом сама глобальная переменная **не изменяется**. Как только мы выходим из функции, снова становится видимой глобальная `x`.

То же самое происходит и с параметрами функции:

```javascript
let x = "global";

function doingStuff(x) { // Параметр 'x' — это локальная переменная
  console.log(x); // Будет использовано значение, переданное в функцию
}

doingStuff("param"); // Передаем значение для параметра 'x'
```

**Результат выполнения:**
```
param
```

### Опасность неявных глобальных переменных

JavaScript может сыграть с вами злую шутку. Посмотрите на этот пример:

```javascript
function confuseReader() {
  x = "Guess my scope..."; // ОПАСНО: нет ключевых слов let/var/const!
  console.log("Inside the function:", x);
}

confuseReader();
console.log("Outside of function:", x); // И она доступна снаружи!
```

**Результат выполнения:**
```
Inside the function: Guess my scope...
Outside of function: Guess my scope...
```

Если вы присваиваете значение переменной, которая не была объявлена (с `let`, `var` или `const`) ни в одной области видимости, JavaScript **автоматически создаёт глобальную переменную**.

**Это ужасная практика!** Такие ошибки сложно искать, особенно в большом коде. Они могут случайно перезаписать другие глобальные переменные и привести к непредсказуемому поведению программы.

**Всегда объявляйте переменные явно** с помощью `let`, `const` или `var`.

## Заключение

Понимание области видимости — фундамент написания хорошего JavaScript-кода.

*   Используйте `const` по умолчанию, а `let` — если значение переменной будет меняться.
*   Старайтесь избегать `var` в новом коде из-за его неочевидного поведения (function scope, hoisting).
*   Объявляйте переменные как можно ближе к месту их использования.
*   Избегайте создания глобальных переменных. Оборачивайте код в функции или модули, чтобы изолировать его.
*   Никогда не создавайте переменные без `let`, `const` или `var`.

