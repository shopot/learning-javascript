# Рекурсивные функции

Рекурсия — это мощная концепция в программировании, которая позволяет функции вызывать саму себя. Это может показаться немного магическим или даже пугающим на первый взгляд, но на самом деле это элегантный инструмент для решения определённого класса задач, где проблема естественным образом делится на более мелкие, но идентичные подзадачи.

Представьте, что вы стоите между двумя зеркалами, расположенными напротив друг друга. Вы видите бесконечное количество своих отражений, уходящих вдаль. Это и есть визуальная аналогия рекурсии — процесс, который повторяет сам себя.

## Как это работает? Базовый принцип

В некоторых случаях решение сложной задачи можно выразить через решение её более простой версии. Рекурсивная функция делает следующее:
1.  **Проверяет базовый случай (условие выхода)**. Это простейший возможный сценарий, при котором ответ известен сразу, и дальнейшие вызовы функции не нужны.
2.  **Если базовый случай не достигнут**, функция выполняет некоторую работу, а затем вызывает *саму себя* с новыми аргументами, которые приближают её к базовому случаю.

Давайте разберём это на примере из вашего материала. Первоначальный код выглядел так:

```javascript
function getRecursive(nr) {
  console.log(nr);
  getRecursive(--nr); // Декремент и вызов
}
getRecursive(3);
```

**Что произойдёт?** Этот код будет выводить числа в консоль бесконечно (или до тех пор, пока не произойдёт переполнение стека вызовов, о котором мы поговорим позже). Сначала он выведет 3, затем 2, 1, 0, -1, -2 и так далее. Почему он не останавливается? Потому что мы не предоставили ему инструкций, когда следует остановиться. У функции отсутствует **базовый случай** — условие, при котором рекурсивные вызовы прекращаются.

## Исправляем ошибку: добавляем условие выхода

Вот исправленная и рабочая версия функции:

```javascript
function getRecursive(nr) {
  console.log(nr); // Выводим текущее число
  if (nr > 0) {   // Это наше условие выхода (базовый случай)
    getRecursive(--nr); // Вызываем себя с числом на единицу меньше
  }
}
getRecursive(3);
```

Теперь функция ведёт себя правильно:
*   Вызывается `getRecursive(3)`.
*   Выводится `3`.
*   Проверяется условие `3 > 0` — оно истинно.
*   Вызывается `getRecursive(2)`.
*   ... и так далее, пока не будет вызвана `getRecursive(0)`.
*   Выводится `0`.
*   Проверяется условие `0 > 0` — оно ложно.
*   Функция `getRecursive(0)` завершает свою работу, не сделав новых вызовов.
*   Управление возвращается в предыдущие вызовы, которые также завершаются.

## Глубина рекурсии и стек вызовов

Чтобы понять, что происходит "под капотом", важно знать о **стеке вызовов** (Call Stack). Стек — это структура данных, которая работает по принципу "последний пришёл — первый ушёл" (LIFO). Когда функция вызывается, интерпретатор JavaScript помещает её в верхушку стека. Когда функция завершает выполнение, она извлекается из стека.

При рекурсии каждый новый вызов функции помещается поверх предыдущего в стеке. Это можно наглядно представить:

1.  **getRecursive(3)** получена и помещена в стек.
2.  Она вызывает **getRecursive(2)**, которая помещается в стек поверх первой.
3.  Та вызывает **getRecursive(1)**, которая добавляется в стек.
4.  Та вызывает **getRecursive(0)**, которая добавляется в стек.
5.  **getRecursive(0)** завершает работу (так как `nr > 0` ложно) и извлекается из стека.
6.  Управление возвращается **getRecursive(1)**, которая завершается и извлекается из стека.
7.  Управление возвращается **getRecursive(2)**, которая завершается и извлекается из стека.
8.  Управление возвращается **getRecursive(3)**, которая завершается и извлекается из стека. Стек пуст.

## Наглядная демонстрация: порядок выполнения

Следующий пример из материала прекрасно демонстрирует этот порядок "погружения" и "всплытия":

```javascript
function logRecursive(nr) {
  console.log("Started function:", nr); // Сообщение при "погружении"
  if (nr > 0) {
    logRecursive(nr - 1); // Рекурсивный вызов
  } else {
    console.log("done with recursion"); // Сообщение в самой глубине
  }
  console.log("Ended function:", nr); // Сообщение при "всплытии"
}
logRecursive(3);
```

Результат в консоли:
```
Started function: 3
Started function: 2
Started function: 1
Started function: 0
done with recursion
Ended function: 0
Ended function: 1
Ended function: 2
Ended function: 3
```

Обратите внимание, что все сообщения `"Started"` выводятся по мере углубления рекурсии (при помещении функций в стек), а сообщения `"Ended"` выводятся в обратном порядке по мере завершения работы каждой функции и извлечения её из стека.

## Классический пример: вычисление факториала

Факториал числа n (обозначается n!) — это произведение всех натуральных чисел от 1 до n.
*   5! = 5 * 4 * 3 * 2 * 1 = 120
*   3! = 3 * 2 * 1 = 6
*   По определению, 0! = 1.

Давайте выразим это рекурсивно:
*   **Базовый случай:** Факториал 0 равен 1.
*   **Рекурсивный случай:** Факториал числа n равен n, умноженному на факториал (n-1).

`n! = n * (n-1)!`

На JavaScript это выглядит так:

```javascript
function factorial(n) {
  // 1. Базовый случай: если n равно 0, возвращаем 1.
  if (n === 0) {
    return 1;
  }
  // 2. Рекурсивный случай: возвращаем n * факториал(n-1)
  else {
    return n * factorial(n - 1);
  }
}

console.log(factorial(5)); // Выведет: 120
console.log(factorial(3)); // Выведет: 6
console.log(factorial(0)); // Выведет: 1
```

Разберём по шагам для `factorial(3)`:
1.  `3 !== 0`, поэтому вычисляется `3 * factorial(2)`.
2.  Для вычисления `factorial(2)` проверяется `2 !== 0`, вычисляется `2 * factorial(1)`.
3.  Для вычисления `factorial(1)` проверяется `1 !== 0`, вычисляется `1 * factorial(0)`.
4.  Для вычисления `factorial(0)` срабатывает базовый случай и возвращается `1`.
5.  Возвращаемся назад: `1 * factorial(0)` = `1 * 1` = `1` (результат `factorial(1)`).
6.  `2 * factorial(1)` = `2 * 1` = `2` (результат `factorial(2)`).
7.  `3 * factorial(2)` = `3 * 2` = `6` (конечный результат).

## Когда использовать рекурсию?

Рекурсия — прекрасный выбор для задач, которые можно разделить на одинаковые подзадачи. Яркие примеры:
*   **Обход древовидных структур:** Файловая система, DOM-дерево в браузере, древовидные меню, синтаксические деревья. Это *идеальная* область для рекурсии.
*   **Сортировка и алгоритмы "разделяй и властвуй":** Алгоритмы быстрой сортировки (Quicksort) и сортировки слиянием (Mergesort) elegantly implemented recursively.
*   **Математические вычисления:** Факториалы, числа Фибоначчи, возведение в степень.

## Важные предостережения

1.  **Всегда определяйте базовый случай.** Самая частая и критичная ошибка — создать рекурсию без условия остановки. Это приводит к бесконечным вызовам и переполнению стека (Stack Overflow error).

2.  **Убедитесь, что рекурсивный вызов приближает к базовому случаю.** Аргументы, с которыми функция вызывает саму себя, должны меняться так, чтобы рано или поздно условие выхода было достигнуто. В нашем примере мы постоянно уменьшали `nr`.

3.  **Помните о производительности.** Каждый рекурсивный вызов потребляет память для размещения нового контекста выполнения в стеке. Для очень глубокой рекурсии это может стать проблемой. В некоторых случаях классический цикл (`for`, `while`) может быть более эффективным по памяти и скорости.

4.  **Хвостовая рекурсия.** В современных стандартах JavaScript (ES6+) существует концепция оптимизации хвостовой рекурсии, когда интерпретатор может reuse the current stack frame for the next call, избегая роста стека. Однако поддержка этой оптимизации не везде одинакова.

## Резюме

Рекурсия — это другой способ организации кода, альтернативный циклам. 

Ключ к успеху — чёткое понимание трёх составляющих:

- **Базовый случай:** Простой сценарий, при котором функция возвращает результат сразу.
- **Рекурсивный случай:** Сценарий, при котором функция вызывает саму себя с изменёнными аргументами.
- **Доверие:** Вера в то, что если ваша функция правильно решает маленькую задачу, то она сможет решить и большую, собрав решение из маленьких частей.

