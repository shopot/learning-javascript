# Список ответов для "Рекурсивные функции"

1. Функция, которая вызывает саму себя в процессе своего выполнения.
   Пояснение: Это основное определение рекурсии. Функция решает большую задачу, разбивая её на меньшие подзадачи того же типа, для решения которых она и вызывает саму себя.

2. Потому что в ней отсутствует условие остановки (базовый случай), что приводит к бесконечным вызовам и переполнению стека.
   Пояснение: Без проверки (nr > 0) функция будет продолжать вызывать себя с отрицательными числами (2, 1, 0, -1, -2...), пока ресурсы системы не исчерпаются.

3. Это простое условие, при котором функция прекращает вызывать саму себя и возвращает конкретное значение. Его роль — остановить рекурсию и предотвратить бесконечные вызовы.
   Пояснение: Базовый случай — это фундамент любой рекурсивной функции. Без него рекурсия не имеет точки остановки, как в примере из вопроса 2.

4. Это специальная структура данных, которая отслеживает вызовы функций. При каждом новом рекурсивном вызове текущая функция "ставится на паузу" и помещается в стек, а управление передаётся новому вызову.
   Пояснение: Стек работает по принципу LIFO (последний пришёл — первый ушёл). Это объясняет, почему функции завершаются в порядке, обратном порядку их вызова.

5. Потому что сообщения "Started function" выводятся на этапе "погружения" в рекурсию (при помещении функций в стек), а сообщения "Ended function" — на этапе "всплытия" (при извлечении функций из стека после завершения самого глубокого вызова).
   Пояснение: Это наглядно демонстрирует порядок работы стека вызовов. Сначала код выполняется до рекурсивного вызова, а код после него выполняется уже на обратном пути.

6. Порядок: factorial(3) -> 3 * factorial(2) -> factorial(2) -> 2 * factorial(1) -> factorial(1) -> 1 * factorial(0) -> factorial(0) возвращает 1 -> затем вычисления идут в обратном порядке: 1 * 1 = 1, 2 * 1 = 2, 3 * 2 = 6.
   Пояснение: Это показывает, что рекурсивные вызовы "раскручиваются" до базового случая (0), и только потом начинается процесс возврата и вычисления конечного результата.

7. Главное преимущество — элегантность и читаемость кода для задач, которые естественным образом решаются через разделение на идентичные подзадачи (например, обход деревьев).
   Пояснение: Для таких задач рекурсивное решение часто гораздо проще для понимания и написания, чем эквивалентное решение с использованием циклов.

8. Главный риск — возможное переполнение стека вызовов из-за слишком большой глубины рекурсии, а также потенциальные затраты памяти и производительности.
   Пояснение: Каждый вызов функции потребляет память. Если глубина рекурсии огромна (или бесконечна), это может привести к аварийной остановке программы.

9. Аргумент должен изменяться таким образом, чтобы с каждым новым вызовом функция неуклонно приближалась к выполнению базового случая (например, уменьшаться или увеличиваться до определённого предела).
   Пояснение: Если аргумент не меняется или меняется неправильно (например, всегда остаётся больше нуля), условие выхода никогда не будет достигнуто.

10. Идеально рекурсия подходит для обхода древовидных структур, таких как файловая система, DOM-дерево, или любая другая иерархическая структура с элементами, содержащими вложенные элементы того же типа.
    Пояснение: Рекурсия позволяет обработать узел, а затем легко применить тот же алгоритм ко всем его дочерним узлам, не зная их точное количество и уровень вложенности заранее.
