#

1.  **Ответ:** `matchAll()` возвращает итератор, который при каждом обращении yields (отдаёт) объект совпадения с полной информацией (как `match()` для неглобального regex), а `match()` с флагом `g` возвращает простой массив только из найденных подстрок.
    **Пояснение:** Это ключевое различие. `match()` даёт только текст совпадений, а `matchAll()` предоставляет полные данные, включая индекс, группы и т.д., что удобно для анализа.

2.  **Ответ:** Флаг глобального поиска `g`.
    **Пояснение:** Без флага `g` регулярное выражение ищет только первое совпадение, и `matchAll()` выбросит исключение TypeError, так как он предназначен для множественного поиска.

3.  **Ответ:** Каждый элемент итератора — это массив, представляющий собой результат одного совпадения. Этот массив аналогичен результату вызова `match()` без флага `g`.
    **Пояснение:** Этот массив содержит в индексе `0` найденную подстроку, а также имеет свойства `index` (позиция совпадения) и `groups` (именованные группы захвата).

4.  **Ответ:** Обратиться к нулевому элементу массива результата: `word[0]` (где `word` — переменная из цикла).
    **Пояснение:** Поскольку результат для каждого совпадения — это массив, первым элементом `[0]` всегда идёт вся найденная подстрока.

5.  **Ответ:** Использовать свойство `.index` объекта результата: `word.index`.
    **Пояснение:** Свойство `index` есть у каждого объекта-результата, возвращаемого итератором `matchAll()`. Оно указывает на начальную позицию найденной подстроки в исходной строке.

6.  **Ответ:** Нет, не изменяет.
    **Пояснение:** В отличие от других методов (например, `exec`), которые могут менять `lastIndex` переданного регулярного выражения, `matchAll()` этого не делает. Это делает его поведение более предсказуемым и避免了 потенциальных ошибок.

7.  **Ответ:** Да, можно. Для этого нужно установить свойство `lastIndex` самого регулярного выражения перед вызовом `matchAll()`.
    **Пояснение:** `matchAll()` читает начальную позицию для поиска из свойства `lastIndex` переданного ему регулярного выражения.

8.  **Ответ:** Метод `split()` предназначен для разделения строки на массив подстрок по указанному разделителю.
    **Пояснение:** Это основной метод для разбиения строки на части. Разделитель может быть как строкой, так и регулярным выражением.

9.  **Ответ:** Строка будет разделена по паттерну, заданному регулярным выражением. Это позволяет использовать сложные условия для поиска разделителя.
    **Пояснение:** Использование regex со `split()` мощнее, чем просто строки-разделители, так как позволяет, например, игнорировать пробелы вокруг запятых или использовать несколько разных символов в качестве разделителя.

10. **Ответ:** Текст, совпавший с захватывающими группами, будет включён в возвращаемый массив в виде отдельных элементов.
    **Пояснение:** Это неочевидное, но полезное поведение. Элементы массива результата будут чередоваться: часть текста до разделителя, затем текст из групп захвата, затем часть после и т.д.

11. **Ответ:** Элемент `"br/"` — это текст, совпавший с первой (и единственной) захватывающей группой `([^>]+)` в регулярном выражении `/&lt;([^>]+)&gt;/`.
    **Пояснение:** Группа `([^>]+)` захватывает всё, что находится внутри угловых скобок `<>`. Метод `split()`, встретив разделитель (`<br/>`), разбивает строку и добавляет в массив текст до разделителя ("Testing"), текст из группы захвата ("br/"), и текст после разделителя ("1,2,3").

12. **Ответ:** Нужно обернуть паттерн в захватывающие скобки: `split(/(\s*,\s*)/`.
    **Пояснение:** Любая часть регулярного выражения, заключённая в круглые скобки `()`, становится захватывающей группой. `split()` автоматически включает совпадения таких групп в результирующий массив.

13. **Ответ:** `matchAll()`, потому что он предоставляет полную информацию о каждом совпадении (индекс, группы) и не мутирует исходное регулярное выражение.
    **Пояснение:** `match()` с флагом `g` даёт только подстроки, без метаданных. Цикл с `RegExp.exec()` может быть громоздким и требует ручного управления `lastIndex`. `matchAll()` решает эти проблемы.

14. **Ответ:** Будет выброшено исключение TypeError.
    **Пояснение:** `matchAll()` по своей сути предназначен для глобального поиска. Если ему передать регулярное выражение без флага `g`, он не сможет выполнить свою задачу и выбросит ошибку.

15.  **Ответ:**
     ```javascript
     const str = "Цены: 100 руб, 200 руб, 300 руб.";
     const regex = /\d+/g; // Регулярное выражение для поиска чисел

for (let match of str.matchAll(regex)) {
console.log(`Число: ${match[0]}, Индекс: ${match.index}`);
}
```
**Пояснение:** Код создаёт итератор с помощью `matchAll()`, который проходит по всем совпадениям регулярного выражения `\d+` (одна или более цифр) в строке. Для каждого совпадения в цикле выводится найденное число (`match[0]`) и его начальная позиция в строке (`match.index`).
