# Класс RegExp

## Конструктор RegExp()

Конструктор `RegExp()` создает новый объект регулярного выражения. Он принимает один или два строковых аргумента:

```javascript
// Синтаксис
new RegExp(pattern[, flags])
```

- **pattern** - строка, содержащая тело регулярного выражения (текст между слешами в литеральной записи)
- **flags** - необязательная строка с флагами: `g`, `i`, `m`, `s`, `u`, `y` или их комбинацией

### Особенности использования

Поскольку и строковые литералы, и регулярные выражения используют символ `\` для экранирования, при передаче шаблона в виде строки необходимо удваивать обратные слеши:

```javascript
// Литеральная запись
let regex1 = /\d{5}/g;

// Через конструктор - обратите внимание на двойные \\
let regex2 = new RegExp("\\d{5}", "g");
```

### Динамическое создание регулярных выражений

Основное преимущество конструктора - возможность создавать регулярные выражения динамически:

```javascript
// Создание регулярного выражения на основе пользовательского ввода
let userInput = prompt("Введите текст для поиска:");
let dynamicRegex = new RegExp(userInput, "gi");
```

### Копирование с изменением флагов

Конструктор позволяет копировать существующее регулярное выражение с изменением флагов:

```javascript
let exactMatch = /JavaScript/;
let caseInsensitive = new RegExp(exactMatch, "i");

console.log(caseInsensitive.test("javascript")); // true
```

## Свойства объектов RegExp

Объекты регулярных выражений имеют следующие свойства:

### source
Только для чтения. Содержит исходный текст регулярного выражения:

```javascript
let regex = /abc/gi;
console.log(regex.source); // "abc"
```

### flags
Только для чтения. Строка с флагами регулярного выражения:

```javascript
let regex = /abc/gi;
console.log(regex.flags); // "gi"
```

### Булевы свойства флагов
Доступные только для чтения свойства, указывающие на наличие конкретных флагов:

```javascript
let regex = /abc/gim;

console.log(regex.global);     // true (флаг g)
console.log(regex.ignoreCase); // false (флаг i)
console.log(regex.multiline);  // true (флаг m)
console.log(regex.dotAll);     // false (флаг s)
console.log(regex.unicode);    // false (флаг u)
console.log(regex.sticky);     // false (флаг y)
```

### lastIndex
Читаемое и изменяемое свойство. Для шаблонов с флагами `g` или `y` указывает позицию, с которой начнется следующий поиск:

```javascript
let regex = /a/g;
let str = "abcabc";

console.log(regex.lastIndex); // 0
regex.test(str);
console.log(regex.lastIndex); // 1
```

## Методы класса RegExp

### test()
Проверяет, соответствует ли строка шаблону. Возвращает `true` или `false`.

```javascript
let zipcode = /\d{5}/;
console.log(zipcode.test("90210")); // true
console.log(zipcode.test("abcde")); // false
```

**Важно:** При использовании с флагами `g` или `y` поведение зависит от свойства `lastIndex`:

```javascript
let regex = /a/g;
let str = "abcabc";

console.log(regex.test(str)); // true (позиция 0)
console.log(regex.test(str)); // true (позиция 3)
console.log(regex.test(str)); // false (больше совпадений нет)
```

### exec()
Наиболее мощный метод для работы с регулярными выражениями. Возвращает массив с информацией о совпадении или `null`.

#### Структура возвращаемого значения

При успешном совпадении `exec()` возвращает массив со следующими свойствами:

- **Элементы массива**:
  - `[0]` - полное совпадение
  - `[1]`, `[2]`, ... - подстроки, соответствующие группам захвата

- **Свойства массива**:
  - `index` - позиция, в которой найдено совпадение
  - `input` - исходная строка
  - `groups` - объект с именованными группами захвата (если есть)

```javascript
let regex = /(\w+)\s(\w+)/;
let str = "John Smith";
let result = regex.exec(str);

console.log(result[0]);    // "John Smith"
console.log(result[1]);    // "John"
console.log(result[2]);    // "Smith"
console.log(result.index); // 0
console.log(result.input); // "John Smith"
```

#### Использование с флагами g и y

При использовании с флагами `g` или `y`, `exec()` обновляет свойство `lastIndex` после каждого успешного совпадения:

```javascript
let pattern = /Java/g;
let text = "JavaScript > Java";
let match;

while ((match = pattern.exec(text)) !== null) {
  console.log(`Найдено: ${match[0]} на позиции ${match.index}`);
  console.log(`Следующий поиск начнется с: ${pattern.lastIndex}`);
}
```

## Свойство lastIndex и повторное использование RegExp

Работа с `lastIndex` может быть источником ошибок. Рассмотрим типичные проблемы и их решения.

### Проблема 1: Бесконечный цикл

```javascript
// НЕПРАВИЛЬНО - возможен бесконечный цикл
let html = "<p>First</p><p>Second</p>";
let match, positions = [];

while ((match = /<p>/g.exec(html)) !== null) {
  positions.push(match.index);
}
```

**Проблема**: На каждой итерации создается новый объект RegExp с `lastIndex = 0`.

**Решение**: Создайте регулярное выражение один раз перед циклом:

```javascript
// ПРАВИЛЬНО
let html = "<p>First</p><p>Second</p>";
let regex = /<p>/g;
let match, positions = [];

while ((match = regex.exec(html)) !== null) {
  positions.push(match.index);
}
```

### Проблема 2: Пропуск совпадений

```javascript
// НЕПРАВИЛЬНО - некоторые слова могут быть пропущены
let dictionary = ["apple", "book", "coffee"];
let doubleLetterWords = [];
let doubleLetter = /(\w)\1/g; // ищем удвоенные буквы

for (let word of dictionary) {
  if (doubleLetter.test(word)) {
    doubleLetterWords.push(word);
  }
}

// Результат: ["apple", "coffee"] - "book" пропущен!
```

**Проблема**: После нахождения "pp" в "apple", `lastIndex` устанавливается в 3. При проверке "book" поиск начинается с позиции 3, и "oo" не находится.

**Решение 1**: Не использовать флаг `g`, если он не нужен:

```javascript
let doubleLetter = /(\w)\1/; // без флага g
```

**Решение 2**: Сбрасывать `lastIndex` перед каждым использованием:

```javascript
for (let word of dictionary) {
  doubleLetter.lastIndex = 0; // сброс перед каждым использованием
  if (doubleLetter.test(word)) {
    doubleLetterWords.push(word);
  }
}
```

**Решение 3**: Создавать новое регулярное выражение для каждой итерации:

```javascript
for (let word of dictionary) {
  if (/(\w)\1/g.test(word)) {
    doubleLetterWords.push(word);
  }
}
```

## Альтернатива: метод String.matchAll() (ES2020+)

В современных версиях JavaScript рекомендуется использовать `String.matchAll()` вместо ручного управления `exec()` и `lastIndex`:

```javascript
let pattern = /Java/g;
let text = "JavaScript > Java";
let matches = text.matchAll(pattern);

for (let match of matches) {
  console.log(`Найдено: ${match[0]} на позиции ${match.index}`);
}
```

**Преимущества** `matchAll()`:
- Не изменяет `lastIndex` исходного регулярного выражения
- Возвращает итератор с полной информацией о каждом совпадении
- Более читаемый и безопасный код

## Практические рекомендации

1. **Для простых проверок** используйте `test()` - он быстрее и проще.

2. **Для извлечения информации** из совпадений используйте `exec()` или `matchAll()`.

3. **Будьте осторожны** с флагами `g` и `y` - они изменяют поведение методов и состояние регулярного выражения.

4. **Избегайте повторного использования** глобальных регулярных выражений без сброса `lastIndex`.

5. **В современных проектах** предпочитайте `String.matchAll()` ручному управлению с помощью `exec()`.

6. **Для динамических шаблонов** всегда используйте конструктор `new RegExp()`.

7. **Экранируйте специальные символы** при создании регулярных выражений из пользовательского ввода для избежания ошибок и уязвимостей.

Это руководство охватывает ключевые аспекты работы с классом `RegExp` в JavaScript. Понимание этих концепций необходимо для эффективного использования регулярных выражений в ваших проектах.
