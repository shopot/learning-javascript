# Сопоставление шаблонов

## Юникод-категории и свойства

Стандартные символьные классы, такие как `\w` и `\d`, работают только с ASCII-символами, что ограничивает их применение для международного текста. Для работы с текстом на различных языках используются Юникод-категории через синтаксис `\p{}`.

Если вам нужно найти любой символ, который не является десятичной цифрой в любом языке, используйте `\P{Decimal_Number}` (обратите внимание на заглавную P). Для поиска любого числоподобного символа, включая дроби и римские цифры, применяйте `\p{Number}`.

Важно отметить, что "Decimal_Number" и "Number" — это не специфичные для JavaScript или грамматики регулярных выражений термины. Это названия категорий символов, определенных стандартом Unicode.

Класс символов `\w` работает только с ASCII-текстом, но с помощью `\p` мы можем создать интернационализированную версию:

```javascript
/[\p{Alphabetic}\p{Decimal_Number}\p{Mark}]/u
```

Для полной совместимости со сложностью мировых языков необходимо также добавить категории "Connector_Punctuation" и "Join_Control".

Синтаксис `\p` также позволяет определять регулярные выражения, которые соответствуют символам из определенного алфавита или письменности:

```javascript
let greekLetter = /\p{Script=Greek}/u;
let cyrillicLetter = /\p{Script=Cyrillic}/u;
```

## Квантификаторы (повторения)

Синтаксис повторений позволяет указать, сколько раз элемент регулярного выражения может повторяться. Символы повторения всегда следуют за шаблоном, к которому они применяются.

### Основные квантификаторы:

- `{n,m}` — соответствует предыдущему элементу не менее n раз, но не более m раз
- `{n,}` — соответствует предыдущему элементу n или более раз
- `{n}` — соответствует ровно n вхождениям предыдущего элемента
- `?` — соответствует нулю или одному вхождению предыдущего элемента (эквивалентно `{0,1}`)
- `+` — соответствует одному или более вхождениям предыдущего элемента (эквивалентно `{1,}`)
- `*` — соответствует нулю или более вхождениям предыдущего элемента (эквивалентно `{0,}`)

### Примеры использования:

```javascript
let r = /\d{2,4}/;    // От двух до четырех цифр
r = /\w{3}\d?/;       // Ровно три буквенных символа и необязательная цифра
r = /\s+java\s+/;     // "java" с одним или более пробелами до и после
r = /[^(]*/;          // Ноль или более символов, не являющихся открывающей скобкой
```

Важно: во всех этих примерах спецификаторы повторения применяются к одиночному символу или классу символов, который предшествует им. Если нужно匹配 повторения более сложных выражений, необходимо определить группу с помощью круглых скобок.

Будьте осторожны при использовании символов повторения `*` и `?`. Поскольку эти символы могут соответствовать нулю экземпляров того, что им предшествует, они могут не соответствовать ничему. Например, регулярное выражение `/a*/` фактически соответствует строке "bbbb", потому что строка содержит нуль вхождений буквы a!

### Нежадные повторения

По умолчанию квантификаторы являются "жадными" — они匹配 как можно больше символов. Чтобы сделать повторение нежадным (ленивым), следует поставить знак вопроса после квантификатора: `??`, `+?`, `*?` или даже `{1,5}?`.

Например, регулярное выражение `/a+/` соответствует одному или более вхождениям буквы a. При применении к строке "aaa" оно соответствует всем трем буквам. Но `/a+?/` соответствует одному или более вхождениям буквы a, находя как можно меньше символов. При применении к той же строке этот шаблон соответствует только первой букве a.

Использование нежадного повторения не всегда дает ожидаемые результаты. Рассмотрим шаблон `/a+b/`, который соответствует одной или более буквам a, за которыми следует буква b. При применении к строке "aaab" он соответствует всей строке. Нежадная версия: `/a+?b/` должна соответствовать букве b, перед которой стоит как можно меньше букв a. При применении к той же строке "aaab" можно ожидать, что она будет соответствовать только одной a и последней букве b. Однако на самом деле этот шаблон соответствует всей строке, как и жадная версия. Это связано с тем, что匹配 регулярных выражений выполняется путем поиска первой позиции в строке, в которой возможно совпадение. Поскольку совпадение возможно, начиная с первого символа строки, более короткие совпадения, начинающиеся с последующих символов, вообще не рассматриваются.

## Альтернативы, группировка и ссылки

### Альтернативы

Символ `|` разделяет альтернативы. Например, `/ab|cd|ef/` соответствует строке "ab", или строке "cd", или строке "ef". А `/\d{3}|[a-z]{4}/` соответствует либо трем цифрам, либо четырем строчным буквам.

Альтернативы рассматриваются слева направо до тех пор, пока не будет найдено совпадение. Если левая альтернатива совпадает, правая альтернатива игнорируется, даже если она могла бы дать "лучшее" совпадение. Таким образом, когда шаблон `/a|ab/` применяется к строке "ab", он соответствует только первой букве.

### Группировка

Круглые скобки служат для группировки отдельных элементов в одно подвыражение, чтобы к ним можно было применять `|`, `*`, `+`, `?` и т.д. как к единому целому.

Например, `/java(script)?/` соответствует "java" с последующим необязательным "script". А `/(ab|cd)+|ef/` соответствует либо строке "ef", либо одному или более повторениям строк "ab" или "cd".

Другое назначение круглых скобок — определение подшаблонов внутри полного шаблона. Когда регулярное выражение успешно匹配 целевой строки, можно извлечь части целевой строки, соответствующие определенному подшаблону в скобках.

Например, если вы ищете одну или более строчных букв, за которыми следует одна или более цифр, вы можете использовать шаблон `/[a-z]+\d+/`. Но если вас интересуют только цифры в конце каждого совпадения, вы можете поместить эту часть шаблона в круглые скобки: `/[a-z]+(\d+)/`.

### Ссылки на группы

Пронумерованные ссылки на подвыражения позволяют обращаться к предыдущему подвыражению later в том же регулярном выражении. Это делается с помощью символа `\`, за которым следует цифра или цифры. Цифры относятся к позиции подвыражения в круглых скобках within регулярного выражения. Например, `\1` refers обратно к первому подвыражению, а `\3` — к третьему.

Поскольку подвыражения могут быть вложены друг в друга, учитывается позиция левой скобки. Например, в следующем регулярном выражении вложенное подвыражение `([Ss]cript)` обозначается как `\2`:

```javascript
/([Jj]ava([Ss]cript)?)\sis\s(fun\w*)/
```

Ссылка на предыдущее подвыражение регулярного выражения refers не к шаблону для этого подвыражения, а к тексту, который соответствует шаблону. Таким образом, ссылки можно использовать для обеспечения того, чтобы отдельные части строки содержали exactly одни и те же символы.

Например, следующее регулярное выражение соответствует нулю или более символам в одинарных или двойных кавычках. Однако оно не требует совпадения открывающих и закрывающих кавычек (т.е. both одинарные или both двойные кавычки):

```javascript
/['"][^'"]*['"]/
```

Чтобы потребовать совпадения кавычек, используйте ссылку:

```javascript
/(['"])[^'"]*\1/
```

`\1` соответствует тому, что matched первое подвыражение в круглых скобках. В этом примере это обеспечивает условие, что закрывающая кавычка совпадает с открывающей. Это регулярное выражение не позволяет использовать одинарные кавычки в строках с двойными кавычками и наоборот.

### Группировка без захвата

Можно группировать элементы в регулярном выражении без создания нумерованной ссылки на эти элементы. Вместо простой группировки элементов within `(` и `)`, начните группу с `(?:` и завершите ее с `)`. Рассмотрим следующий шаблон:

```javascript
/([Jj]ava(?:[Ss]cript)?)\sis\s(fun\w*)/
```

В этом примере подвыражение `(?:[Ss]cript)` используется только для группировки, поэтому символ повторения `?` может быть применен к группе. Эти модифицированные круглые скобки не создают ссылку, поэтому в этом регулярном выражении `\2` refers к тексту, соответствующему `(fun\w*)`.

## Именованные группы захвата

Именованные группы захвата — это функция, которая делает регулярные выражения более самоописываемыми и понятными. Она позволяет связать имя с каждой левой скобкой в регулярном выражении, чтобы мы могли ссылаться на соответствующий текст по имени, а не по номеру. Что equally важно, использование имен позволяет читающему код легче понять назначение этой части регулярного выражения.

Чтобы named группу, используйте `(?<...>)` вместо `(` и поместите имя между угловыми скобками. Например, вот регулярное выражение, которое может использоваться для проверки форматирования последней строки почтового адреса в США:

```javascript
/(?<city>\w+) (?<state>[A-Z]{2}) (?<zipcode>\d{5})(?<zip9>-\d{4})?/
```

Имена групп предоставляют контекст, который делает регулярное выражение более понятным.

Если вы хотите ссылаться на именованную группу захвата within регулярного выражения, вы можете сделать это по имени. Например, мы можем переписать регулярное выражение для匹配 строк в кавычках с использованием именованной группы захвата и именованной обратной ссылки:

```javascript
/(?<quote>['"])[^'"]*\k<quote>/
```

`\k<quote>` — это именованная обратная ссылка на именованную группу, которая захватывает открывающую кавычку.

## Утверждения (анкоры)

Некоторые элементы регулярного выражения匹配 позиции between символов, а не сами символы. Наиболее часто используемые элементы-якоря — это `^`, который привязывает шаблон к началу строки, и `$`, который привязывает шаблон к концу строки.

Элемент `\b` соответствует границе слова ASCII — границе между `\w` (символом слова ASCII) и `\W` (несловесным символом) или между символом слова ASCII и началом или концом строки. Элемент `\B` привязывает совпадение к месту, которое не является границей слова.

### Опережающие утверждения

Если включить выражение в `(?=` и `)`, это опережающее утверждение, которое указывает, что заключенные символы должны совпадать, без фактического их匹配. Например, чтобы匹配 название распространенного языка программирования, но только если за ним следует двоеточие:

```javascript
/[Jj]ava([Ss]cript)?(?=\:)/
```

Этот шаблон соответствует слову "JavaScript" в "JavaScript: The Definitive Guide", но не соответствует "Java" в "Java in a Nutshell", потому что за ним не следует двоеточие.

Если ввести утверждение с `(?!`, это отрицательное опережающее утверждение, которое указывает, что следующие символы не должны совпадать. Например:

```javascript
/Java(?!Script)([A-Z]\w*)/
```

Соответствует "Java", за которой следует заглавная буква и любое количество additional буквенных символов ASCII, при условии, что "Java" не следует за "Script". Он соответствует "JavaBeans", но не "Javanese", и соответствует "JavaScrip", но не "JavaScript" или "JavaScripter".

### Ретроспективные утверждения

Ретроспективные утверждения похожи на опережающие утверждения, но относятся к тексту before текущей позиции совпадения.

Положительное ретроспективное утверждение задается с помощью `(?<=...)`, а отрицательное ретроспективное утверждение — с помощью `(?<!...)`. Например, если вы работаете с почтовыми адресами США, вы можете匹配 5-значный почтовый индекс, но только когда он следует за двухбуквенным缩写ом штата:

```javascript
/(?<= [A-Z]{2} )\d{5}/
```

И вы можете匹配 строку цифр, которой не предшествует символ валюты Unicode, с помощью отрицательного ретроспективного утверждения:

```javascript
/(?<![\p{Currency_Symbol}\d.])\d+(\.\d+)?/u
```

## Флаги регулярных выражений

Каждое регулярное выражение может иметь один или несколько флагов, изменяющих его поведение при匹配.

### Основные флаги:

- `g` — глобальный поиск (находит все совпадения, а не только первое)
- `i` — case-insensitive (независимость от регистра)
- `m` — многострочный режим (якоря `^` и `$`匹配 начало и конец каждой строки)
- `s` — single-line mode (точка `.`匹配 также символы переноса строки)
- `u` — Unicode (полная поддержка Юникода, включая символы beyond 16 бит)
- `y` — sticky (поиск с привязкой к позиции, аналогично якорю `^`)

Флаги можно указывать в любом сочетании и порядке. Например, если вы хотите, чтобы ваше регулярное выражение было Unicode-совместимым, выполняло поиск без учета регистра и предназначалось для поиска нескольких совпадений в строке, вы должны указать флаги `uig`, `gui` или любую другую перестановку этих трех букв.

Флаг `u` особенно важен для работы с современным текстом, содержащим эмодзи и другие символы, требующие более 16 бит. Без флага `u` символ "." соответствует любому 1 UTF-16 16-битному значению. С флагом "." соответствует одному кодовому пункту Unicode, включая те, которые имеют более 16 бит.
