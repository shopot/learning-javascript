# Список ответов по теме "Сопоставление шаблонов"

Конечно, вот ответы на ваши вопросы:

**1.** `\w` (символ слова), `\d` (цифра), `\s` (пробельный символ). Они ограничены только символами из таблицы ASCII и не работают с символами других языков, например, кириллицей или иероглифами.

**2.** Синтаксис `\p{}` с флагом `u`. Например, `\p{Letter}` для поиска букв любого языка.

**3.** `\p{Decimal_Number}` соответствует любому символу, который является десятичной цифрой в любом языке (например, арабские цифры ٠١٢٣). `\P{Decimal_Number}` (с заглавной P) соответствует любому символу, который НЕ является десятичной цифрой.

**4.** `[\p{Alphabetic}\p{Decimal_Number}\p{Mark}]`. Этот набор категорий охватывает буквы, цифры и диакритические знаки (акценты) из всех языков, а не только латинские символы, как `\w`.

**5.** С помощью свойства `Script`. Например, `\p{Script=Greek}` для греческого алфавита, `\p{Script=Cyrillic}` для кириллицы.

**6.** Квантификатор `{n,m}` означает, что предыдущий элемент должен повториться не менее `n` раз, но не более `m` раз. Он задает точный диапазон повторений.

**7.** `?` - ноль или одно повторение, `+` - одно или более повторений, `*` - ноль или более повторений.

**8.** Потому что квантификатор `*` означает "ноль или более". Строка "bbbb" содержит ноль символов 'a', что удовлетворяет условию совпадения.

**9.** Чтобы сделать квантификатор нежадным, после него нужно поставить знак вопроса `?`. Например: `*?`, `+?`, `{n,m}?`.

**10.** Потому что механизм регулярных выражений ищет совпадения слева направо. Он находит первое возможное место, где совпадение удовлетворяет всему шаблону (`a+?b`), которым в случае "aaab" является вся строка.

**11.** Символ `|` разделяет варианты выбора. Регулярное выражение попытается найти совпадение сначала с левой частью от `|`, и только если не получится — перейдет к правой.

**12.** Круглые скобки `()` используются для: 1) группировки элементов, чтобы применять к ним квантификаторы как к целому; 2) захвата части совпадения для использования в результатах или обратных ссылках.

**13.** Для создания обратной ссылки используется синтаксис `\n`, где `n` — номер группы. Например, `\1` ссылается на текст, который matched первая группа.

**14.** Это группировка, которая не создает захватываемую группу и не запоминает совпадение для обратных ссылок. Синтаксис: `(?:...)`. Это полезно для применения квантификаторов без ненужного захвата.

**15.** Именованная группа создается с помощью синтаксиса `(?<name>...)`. Ссылаться на нее внутри выражения можно по имени с помощью `\k<name>`.

**16.** Это утверждения (анкоры), которые проверяют условие в определенной позиции строки, не потребляя символов. Основные: `^` (начало строки), `$` (конец строки), `\b` (граница слова).

**17.** Опережающее утверждение проверяет, что за текущей позицией следует определенный шаблон, но не включает его в результат совпадения. Синтаксис: `(?=...)` для положительного и `(?!...)` для отрицательного утверждения.

**18.** Положительное опережающее утверждение `(?=...)` требует, чтобы после основной части совпадения ШЕЛ указанный шаблон. Отрицательное `(?!...)` требует, чтобы после НЕ ШЕЛ указанный шаблон.

**19.** Ретроспективные утверждения проверяют, что ДО текущей позиции находится (или не находится) определенный шаблон. Синтаксис: `(?<=...)` (положительное) и `(?<!...)` (отрицательное). Они менее распространены из-за ограниченной поддержки в некоторых браузерах.

**20.**
- `g` — глобальный поиск (все совпадения)
- `i` — игнорирование регистра
- `m` — многострочный режим (`^` и `$` для начала/конца каждой строки)
- `s` — чтобы точка `.`匹配 также символ переноса строки
- `u` — полная поддержка Юникода
- `y` — "липкий" поиск (совпадение должно начинаться строго с текущей позиции)

**21.** Флаг `u` обеспечивает корректную обработку символов Юникода, которые занимают более 16 бит (суррогатные пары), например, эмодзи или некоторые редкие иероглифы. Без него такие символы обрабатываются некорректно.

**22.** Без флага `s` точка `.` не匹配 символы переноса строки (`\n`, `\r`). С флагом `s` (single-line) точка `.`匹配 абсолютно любой символ, включая перенос строки.

**23.** Флаг `y` заставляет поиск начинаться не с начала строки, а строго с той позиции, которая указана в свойстве `lastIndex` регулярного выражения. В отличие от `^`, который всегда привязан к началу строки или (с флагом `m`) начала каждой строки.

**24.** Без флага `m` якоря `^` и `$` означают начало и конец всей строки. С флагом `m` (multiline) они означают начало и конец КАЖДОЙ отдельной строки внутри многострочной строки.

**25.** Флаги можно указывать в любом порядке и любом сочетании. `/regex/giu`, `/regex/ugi` и `/regex/igu` — это абсолютно одинаковые записи.
