# Цикл Событий (Event Loop)

## Однопоточная природа JavaScript

JavaScript — однопоточный язык. Это значит, что в один момент времени он может выполнять только одну операцию. Представьте, что у вас только один повар на кухне. Если бы он готовил блюда строго по порядку, не начиная новое, пока не закончит предыдущее, то заказ на пиццу (которая печется 20 минут) заставил бы всех ждать, а заказ на кофе был бы готов только через 20 минут. Это привело бы к "блокировке" интерфейса, делая сайты неотзывчивыми.

Это и есть главный вызов: **JavaScript — однопоточный язык**. Это означает, что у него есть только один "путь выполнения" (thread). В любой момент времени может выполняться только одна инструкция.

Чтобы избежать этого, JavaScript использует **асинхронность**, управляемую **Event Loop** (Событийным циклом). Это и есть наш повар, который умеет грамотно распределять задачи: поставил пиццу в духовку и пошел готовить кофе, не дожидаясь, пока пицца испечется.

Давайте разберемся, как устроена эта "кухня".

## Основные компоненты

Чтобы понять **Event Loop**, нужно сначала знать основных "игроков" на поле.

### Call Stack (Стэк вызовов)

**Что это?** Проще говоря, это список-структура данных по принципу **LIFO** (Last In, First Out — последним пришел, первым ушел). Представьте стопку тарелок: вы можете класть новую тарелку только сверху и брать тоже только сверху.

**Как работает?** Когда скрипт вызывает функцию, она добавляется (push) на верх стека. Когда выполнение функции завершается, она убирается (pop) с верха стека.

**Пример:**
```javascript
function multiply(a, b) {
    return a * b;
}

function square(n) {
    return multiply(n, n); // Эта функция добавляется в стэк
}

function printSquare(n) {
    let squared = square(n); // Затем эта
    console.log(squared); // И наконец эта
}

printSquare(4); // Вызываем первую функцию
```
**Визуализация работы Call Stack:**
1.  `printSquare(4)` добавляется в стэк.
2.  Внутри `printSquare` вызывается `square(4)`. `square(4)` добавляется поверх стэка.
3.  Внутри `square` вызывается `multiply(4, 4)`. `multiply(4, 4)` добавляется поверх стэка.
4.  `multiply` выполняется и возвращает `16`. Она *убирается* из стэка.
5.  `square` возвращает `16`. Она *убирается* из стэка.
6.  `console.log(16)` добавляется в стэк, выполняется (печатает 16 в консоли) и убирается.
7.  `printSquare` завершает работу и убирается из стэка. Стэк пуст.

### Heap (Куча)

**Что это?** Неструктурированная область памяти, где хранятся объекты, переменные и все остальные данные, которые нужны вашей программе. Когда вы создаете объект с помощью `new Object()` или `{}`, он помещается в кучу. Call Stack лишь хранит ссылки на эти объекты.

### Web APIs (Веб-API)

**Что это?** Это функции и возможности, предоставляемые *браузером* (или средой выполнения подобно Node.js), а не самим ядром JavaScript. Так как JavaScript работает в браузере, у него есть доступ к этим инструментам.

**Примеры Web APIs:**
*   `setTimeout()` и `setInterval()`
*   DOM-события (`click`, `keypress`, `mousemove` и т.д.)
*   HTTP-запросы (`fetch()`, `XMLHttpRequest`)
*   Работа с localStorage и т.д.

**Ключевой момент:** Когда асинхронная операция (например, `setTimeout`) вызывается из Call Stack, она немедленно передается на обработку соответствующему Web API. Web API берет на себя заботу об этой операции *вне основного потока* JavaScript.

## Механизм асинхронности: Очереди и Цикл

Теперь посмотрим, что происходит с операцией после того, как Web API ее обработал.

### Callback Queue (Очередь колбэков) / Macrotask Queue (Очередь макрозадач)

**Что это?** Это очередь-структура данных по принципу **FIFO** (First In, First Out — первым пришел, первым ушел). Представьте обычную очередь в магазине.

**Как работает?** Когда Web API завершает свою работу (истечет таймер `setTimeout`, придет ответ от сервера, пользователь кликнет по кнопке), функция-колбэк, которая должна быть выполнена, помещается в эту очередь.

### Event Loop (Событийный цикл)

**Что это?** Это бесконечный цикл, который постоянно проверяет одно простое условие: **"Пуст ли Call Stack?"**.

**Его работа:**
1.  Проверить, пуст ли Call Stack.
2.  Если Call Stack *пуст*, проверить, есть ли задачи в Callback Queue.
3.  Если в Callback Queue есть задачи, взять *первую* из очереди и поместить ее в Call Stack для выполнения.
4.  Повторять этот процесс снова и снова.

Event Loop — это тот самый менеджер, который связывает однопоточный Call Stack с асинхронными возможностями Web APIs. Он гарантирует, что колбэки из очереди будут выполнены только тогда, когда основной код завершится и стэк очистится.

## Микрозадачи (MicroTasks) и Макрозадачи (MacroTasks)

До сих пор мы говорили об одной очереди (Callback Queue). Но на самом деле их две, и они имеют разный приоритет.

### Макрозадачи (MacroTasks)

**Что это?** Это те самые "классические" асинхронные задачи, которые мы уже обсудили.
**Что к ним относится?**
*   `setTimeout` и `setInterval`
*   `setImmediate` (в Node.js)
*   Обработчики событий (click, keypress, mousemove и т.д.)
*   `requestAnimationFrame`
*   I/O операции (чтение файлов в Node.js)

### Микрозадачи (MicroTasks)

**Что это?** Это задачи, которые имеют **наивысший приоритет** и выполняются сразу после выполнения текущего синхронного кода (т.е. после очистки Call Stack), но *до* того, как Event Loop возьмется за любую макрозадачу из очереди или за рендеринг.

**Что к ним относится?**
*   **Колбэки промисов** (`.then()`, `.catch()`, `.finally()`)
*   `async/await` (под капотом это тоже промисы)
*   `queueMicrotask(function)` — специальная функция для прямой постановки в очередь микрозадач.
*   `MutationObserver` (для наблюдения за изменениями в DOM).

### Обновленный алгоритм Event Loop

Теперь полная картина выглядит так:

1.  **Выполнить весь синхронный код** из Call Stack (все, что не является асинхронным).
2.  **Когда Call Stack очистился:**
*   Выполнить **все готовые к выполнению микрозадачи** из очереди микрозадач. Очередь микрозадач должна быть **полностью очищена** перед следующим шагом.
*   При выполнении микрозадач они сами могут добавлять новые микрозадачи, которые также будут выполнены в рамках этой же итерации. Это может потенциально заблокировать цикл, если микрозадачи будут добавляться бесконечно.
3.  **Выполнить рендеринг** (если браузеру нужно перерисовать страницу). Это не часть JavaScript, но часть цикла браузера.
4.  Взять **первую макрозадачу** из очереди макрозадач и выполнить ее.
5.  Вернуться к шагу 2.

**Важнейшее правило: Очередь микрозадач очищается целиком после каждой макрозадачи.**
То есть после выполнения все микрозадач будет выполненна только одна макрозадача.

## Практические примеры

### Порядок выполнения (Macro vs Micro)

```javascript
console.log('Старт'); // 1. Синхронный код

setTimeout(() => {
  console.log('setTimeout'); // 5. Макрозадача
}, 0);

Promise.resolve()
  .then(() => {
    console.log('Промис 1'); // 3. Микрозадача
  })
  .then(() => {
    console.log('Промис 2'); // 4. Микрозадача (добавленная во время выполнения предыдущей микрозадачи)
  });

console.log('Конец'); // 2. Синхронный код

// Вывод:
// Старт
// Конец
// Промис 1
// Промис 2
// setTimeout
```
**Разбор:**
1.  Синхронный код (`console.log`) выполняется сразу, очищая Call Stack.
2.  Event Loop видит, что стэк пуст, и проверяет очередь *микрозадач*. Там колбэк промиса. Он выполняется (`Промис 1`).
3.  После выполнения `Промис 1` в очередь микрозадач добавляется следующий `.then` (`Промис 2`). Event Loop видит, что очередь микрозадач *не пуста*, и выполняет следующую задачу из нее.
4.  Теперь очередь микрозадач пуста. Event Loop переходит к очереди *макрозадач* и выполняет колбэк `setTimeout`.

### Как `setTimeout` с задержкой 0 не является настоящим "0"

```javascript
console.log('Start');

// Этот setTimeout будет ждать как минимум 4мс и, что важнее, завершения всей текущей работы
setTimeout(() => {
  console.log('Timeout');
}, 0);

// Долгая синхронная операция (имитация)
let now = Date.now();
while (Date.now() - now < 3000) {} // Блокируем поток на 3 секунды

console.log('End after 3 seconds');

// Вывод:
// Start
// ... (пауза 3 секунды)
// End after 3 seconds
// Timeout
```
**Разбор:** Web API запускает таймер сразу, но колбэк `setTimeout` не может попасть в Callback Queue и быть выполненным, пока Call Stack не очистится. А он заблокирован циклом `while` на 3 секунды.

### Пример 3: Разбиение тяжелой задачи (как в вашем материале)

```javascript
let i = 0;
let start = Date.now();

function count() {
  if (i < 1_000_000) {
    // setTimeout с задержкой 0 позволяет браузеру "вздохнуть"
    setTimeout(count, 0); // Это макрозадача
  }
  // Делаем часть работы
  do {
    i++;
  } while (i % 100000 != 0);

  if (i === 1000000) {
    alert(`Done in ${Date.now() - start}ms`);
  }
}

count();
```
**Почему это работает?** `setTimeout` планирует каждую следующую итерацию функции `count` как новую макрозадачу. Между этими задачами Event Loop имеет возможность обработать другие события (клики, рендеринг), поэтому интерфейс не "зависает".

### Пример 4: `queueMicrotask` vs `setTimeout`

```javascript
console.log('Start');

setTimeout(() => console.log('Timeout (Macro)'), 0);

queueMicrotask(() => console.log('Microtask'));

console.log('End');

// Вывод:
// Start
// End
// Microtask   <- Микрозадача всегда приоритетнееa
// Timeout (Macro)
```

## Итоговая таблица

| Компонент | Что делает? | Приоритет |
| :--- | :--- | :--- |
| **Call Stack** | Выполняет синхронный код по принципу LIFO. | Наивысший (выполняется немедленно) |
| **Web APIs** | Обрабатывает асинхронные операции (таймеры, запросы). | Вне основного потока |
| **MicroTask Queue** | Очередь для колбэков промисов и `queueMicrotask`. | **Высокий** (выполняется сразу после текущего стэка, *до* макрозадач и рендеринга) |
| **MacroTask Queue** | Очередь для `setTimeout`, событий и т.д. | **Низкий** (выполняется после очистки стэка и всей очереди микрозадач) |
| **Event Loop** | Постоянно проверяет стэк и очереди, решая, что выполнить next. | Связующее звено |

## Заключение

Понимание Event Loop — это ключ к написанию эффективного, неблокирующего кода и к debug'ингу странного поведения асинхронных операций. Главные выводы:

1.  **Синхронный код всегда выполняется первым.**
2.  **Микрозадачи (промисы) выполняются прямо после синхронного кода, но до макрозадач и рендеринга.**
3.  **Макрозадачи (`setTimeout`, события) ждут своей очереди после всего остального.**


