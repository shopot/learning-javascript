# Операторы async и await

В ECMAScript версии 2017 появились async functions и ключевое слово await (ECMAScript Next support in Mozilla). На самом деле, эти функции есть ничего иное как синтаксический сахар над Promises и Generator functions (ts39). С их помощью легче писать и читать асинхронный код, ведь они позволяют использовать привычный синхронный стиль написания. В этой статье мы на базовом уровне разберёмся в их устройстве.

## Зачем нужны async/await?

Представьте, что вы пишете код, который должен:

1.  Получить данные пользователя из базы данных.
2.  Затем, используя эти данные, загрузить его последние заказы.
3.  После этого отправить ему уведомление.

С классическими промисами это могло бы выглядеть как цепочка из `.then()`, которая немного усложняет чтение логики:

```javascript
getUser()
  .then(user => getOrders(user.id))
  .then(orders => sendNotification(orders))
  .catch(error => console.error(error));
```

`async/await` позволяют переписать этот код так, как если бы он был последовательным и синхронным, что значительно упрощает его понимание и поддержку.

## Основная идея: Сахар для Промисов

`async` и `await` — это не магия, а так называемый "синтаксический сахар" поверх промисов. Они не добавляют в язык новых возможностей, которые бы не могли сделать промисы, но делают существующие возможности **гораздо удобнее в использовании**.

## Ключевое слово `async`

Любую функцию можно превратить в асинхронную, добавив перед ее объявлением ключевое слово `async`.

```javascript
// Обычная функция
function syncFunction() {
  return 42;
}

// Асинхронная функция
async function asyncFunction() {
  return 42;
}
```

**Что делает `async`?**

1.  **Всегда возвращает промис.** Даже если тело функции возвращает обычное значение (как `42` в примере выше), JavaScript автоматически обернет это значение в разрешенный (fulfilled) промис.
2.  **Позволяет использовать внутри функции ключевое слово `await`**.

Если выполнить код выше:
```javascript
console.log(syncFunction()); // Вывод: 42
console.log(asyncFunction()); // Вывод: Promise { 42 }
```
Вторая функция вернула не число, а промис, который успешно разрешился со значением `42`.

## Ключевое слово `await`

Ключевое слово `await` можно использовать **только внутри** функций, объявленных с помощью `async`. Оно ставится перед любым выражением, которое возвращает промис.

**Что делает `await`?**

Оно **заставляет JavaScript приостановить выполнение асинхронной функции** и ждать до тех пор, пока переданный ему промис не будет разрешен (fulfilled) или отклонен (rejected).

- Если промис разрешается успешно, `await` возвращает его результат.
- Если промис отклоняется, `await` генерирует исключение (выбрасывает ошибку), как если бы на этом месте сработал оператор `throw`.

**Важное замечание:** `await` не останавливает весь ваш скрипт или браузер. Он приостанавливает только выполнение *текущей асинхронной функции*. Пока функция ждет, JavaScript может спокойно выполнять другой код: обрабатывать клики мыши, запускать таймеры и т.д.

## Разбираем ваш пример по косточкам

Давайте вернемся к коду из вашего материала и пройдемся по нему шаг за шагом.

```javascript
// 1. Эта функция возвращает промис.
function saySomething(x) {
  return new Promise(resolve => {
    // 3. Промис будет разрешен через 2 секунды.
    setTimeout(() => {
      resolve("something" + x); // 4. Промис разрешится со значением "somethingX"
    }, 2000);
  });
}

// 5. Объявляем асинхронную функцию talk.
async function talk(x) {
  // 6. Вызываем saySomething(x), которая возвращает промис.
  // 7. Ключевое слово await ЖДЕТ, пока этот промис не разрешится.
  //    Выполнение функции talk на этой строке приостанавливается.
  const words = await saySomething(x);
  
  // 10. Через 2 секунды промис разрешился, await вернул его значение ("somethingX").
  //     Выполнение функции возобновляется, и значение присваивается переменной `words`.
  console.log(words); // 11. Выводим значение в консоль.
}

// 2. Вызываем асинхронную функцию talk три раза подряд.
talk(2); // -> Через ~2 сек. в консоли: "something2"
talk(4); // -> Через ~2 сек. в консоли: "something4"
talk(8); // -> Через ~2 сек. в консоли: "something8"
```

**Почему все три вызова выполняются "одновременно"?**

Вызовы `talk(2)`, `talk(4)`, `talk(8)` происходят друг за другом практически мгновенно. Каждый вызов доходит до `await` и начинает ждать разрешения своего промиса. Таймеры в всех трех промисах (`setTimeout`) запускаются почти в один и тот же момент и отсчитывают свои 2 секунды параллельно. Поэтому результаты появятся в консоли почти одновременно, примерно через 2 секунды после запуска, а не через 6 (2+2+2).

Это демонстрирует параллельное выполнение асинхронных операций.

## Обработка ошибок с try...catch

Самое большое преимущество `async/await` — это возможность использовать привычные конструкции `try...catch` для обработки ошибок вместо `.catch()` в цепочках промисов.

Если промис, перед которым стоит `await`, будет отклонен (rejected), он выбросит исключение.

```javascript
async function fetchData() {
  try {
    // Пытаемся дождаться результата промиса
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('Успех!', data);
  } catch (error) {
    // Ловим любую ошибку, возникшую в блоке try
    // Будь то ошибка от await или любая другая (например, SyntaxError от .json())
    console.error('Ой, ошибка!', error);
  }
}

fetchData();
```
Этот код гораздо чище и интуитивно понятнее, чем цепочка из `.then().catch()`.

## Частые ошибки и важные моменты

1.  **`await` только внутри `async`**. Это вызовет ошибку:
    ```javascript
    function main() {
      await doSomething(); // SyntaxError: await is only valid in async function
    }
    ```

2.  **Не забывайте про `await`**. Самая частая ошибка — забыть поставить `await`. Вместо результата промиса вы получите объект промиса в состоянии `pending`.
    ```javascript
    async function talk(x) {
      const words = saySomething(x); // Ой! Забыл await!
      console.log(words); // Вывод: Promise { <pending> }
    }
    ```

3.  **Последовательное vs. Параллельное выполнение**. Иногда операции не зависят друг от друга, и их не нужно ждать последовательно.
    **Неоптимально (ждем по очереди):**
    ```javascript
    async function slowSequence() {
      const user = await fetchUser(); // Ждем...
      const orders = await fetchOrders(); // ...ждем еще...
      const notifications = await fetchNotifications(); // ...и еще.
      // Общее время ожидания = сумма всех запросов.
    }
    ```
    **Оптимально (запускаем все сразу и ждем параллельно):**
    ```javascript
    async function fastParallel() {
      // Запускаем все промисы сразу, не дожидаясь друг друга.
      const userPromise = fetchUser();
      const ordersPromise = fetchOrders();
      const notificationsPromise = fetchNotifications();
      
      // А здесь ждем, когда они все одновременно выполнятся.
      const [user, orders, notifications] = await Promise.all([
        userPromise,
        ordersPromise,
        notificationsPromise
      ]);
      // Общее время ожидания = времени самого медленного запроса.
    }
    ```

