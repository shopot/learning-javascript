# Список ответов для раздела "Функция обратного вызова"

1. Параллелизм в JavaScript — это концепция, которая позволяет выполнять несколько операций (например, ожидание ответа от сервера, обработку таймеров) не по очереди, а условно "одновременно", не блокируя основной поток выполнения программы.
   Пояснение: JavaScript является однопоточным, но благодаря механизмам вроде цикла событий (Event Loop) и асинхронным операциям он может эффективно переключаться между задачами, создавая иллюзию параллельной работы.

2. Пример: Синхронный подход — вы моете посуду, и только закончив, начинаете разбирать белье. Асинхронный — вы ставите греться чайник и, пока он кипятится, начинаете мыть посуду. Вы не ждете у чайника, а делаете другую работу, пока он не свистнет.
   Пояснение: Этот пример показывает разницу между блокирующим (ожидание завершения одной задачи) и неблокирующим (запуск задачи и выполнение других действий в ожидании ее результата) выполнением.

3. Функция обратного вызова — это любая функция, которая передается в качестве аргумента в другую функцию с ожиданием, что она будет вызвана по завершению какой-либо операции.
   Пояснение: Ключевая идея — "вызови меня, когда закончишь". Это не особый синтаксис, а паттерн использования обычных функций.

4. Круглые скобки не ставятся, потому что мы не хотим вызывать функцию немедленно в момент передачи. Мы хотим передать ссылку на эту функцию, чтобы она могла быть вызвана позже, внутри той функции, в которую ее передают.
   Пояснение: Синтаксис `someFunction` передает саму функцию. Синтаксис `someFunction()` немедленно вызывает эту функцию и передает результат ее выполнения.

5. Главное преимущество — это разделение кода на логические части и возможность повторного использования. Функция `getGrade` отвечает только за вычисление оценки, а функция `showResult` — за ее отображение. Это позволяет легко менять способ отображения, не изменяя логику вычислений.
   Пояснение: Такой подход соответствует принципу единственной ответственности (Single Responsibility Principle), что делает код более чистым, гибким и легким для поддержки.

6. Яркие примеры — встроенные функции `setTimeout()` и `setInterval()`, которые принимают функцию-колбэк и время задержки/интервал.
   Пояснение: Эти функции планируют выполнение переданного колбэка на будущее, что является классическим примером асинхронной операции в JavaScript.

7. "Ад обратных вызовов" — это ситуация, когда множество асинхронных операций, зависящих друг от друга, приводят к глубокой вложенности колбэков. Код становится похож на елку из множества отступов `})})})`, его очень сложно читать, отлаживать и поддерживать.
   Пояснение: Это антипаттерн, который возникает при интенсивном использовании асинхронных колбэков до появления Promises и async/await.

8. Промисы и async/await решают проблему "Ада обратных вызовов". Они позволяют писать асинхронный код в более линейном, последовательном стиле, который гораздо проще читать и понимать, и который лучше обрабатывает ошибки.
   Пояснение: Эти технологии позволяют "распаковать" вложенные колбэки в цепочки методов `.then().catch()` или использовать синтаксис `await`, который делает асинхронный код визуально похожим на синхронный.

9. Нет, функция обратного вызова не является отдельным типом. Это любая обычная функция (именованная или анонимная), которая используется по определенному паттерну — передается как аргумент для последующего вызова.
   Пояснение: Любую функцию можно использовать как колбэк. Специального ключевого слова или объявления для этого не требуется, это вопрос не синтаксиса, а способа применения.

10. Вызов функции: `processData("hello world", console.log);`
    Пояснение: Здесь `"hello world"` — данные, а `console.log` — функция, которая передается как аргумент (колбэк). Функция `processData` преобразует строку к верхнему регистру и затем вызывает `console.log` с результатом, выводя "HELLO WORLD".
