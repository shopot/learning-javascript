# Операторы `break` и `continue`

В JavaScript циклы позволяют выполнять повторяющиеся действия. Однако иногда нужно прервать текущую итерацию или полностью выйти из цикла. Для этого используются операторы `break` и `continue`.

## Оператор `break`

Оператор `break` немедленно завершает выполнение цикла, даже если условие цикла всё ещё `true`.

### Прерывание цикла при достижении условия

```javascript
for (let i = 0; i < 10; i++) {
  console.log(i);
  if (i === 4) {
    break; // цикл завершится, когда i станет равным 4
  }
}
```  
Вывод:
```
0
1
2
3
4
```  

### Поиск нужного элемента в массиве

Допустим, у нас есть массив автомобилей, и мы хотим найти первую чёрную машину, выпущенную не раньше 2020 года:

```javascript
let cars = [
  { model: "Golf", make: "Volkswagen", year: 1999, color: "black" },
  { model: "Picanto", make: "Kia", year: 2020, color: "red" },
  { model: "Peugeot", make: "208", year: 2021, color: "black" },
  { model: "Fiat", make: "Punto", year: 2020, color: "black" }
];

for (let i = 0; i < cars.length; i++) {
  if (cars[i].year >= 2020 && cars[i].color === "black") {
    console.log("Найдена подходящая машина:", cars[i]);
    break; // поиск прекращается после первого совпадения
  }
}
```  
Вывод:
```
Найдена подходящая машина: { model: 'Peugeot', make: '208', year: 2021, color: 'black' }
```  

### Когда `break` может быть вреден?

Иногда `break` делает код менее читаемым, особенно если условие выхода сложное. Вместо:

```javascript
while (true) {
  if (superLongArray[0] !== 42 && superLongArray.length > 0) {
    superLongArray.shift();
  } else {
    console.log("Найдено 42!");
    break;
  }
}
```  

Лучше использовать явное условие:

```javascript
let notFound = true;
while (superLongArray.length > 0 && notFound) {
  if (superLongArray[0] !== 42) {
    superLongArray.shift();
  } else {
    console.log("Найдено 42!");
    notFound = false;
  }
}
```  

## Оператор `continue`

Оператор `continue` пропускает текущую итерацию и переходит к следующей.

### Пропуск элементов, не соответствующих условию

```javascript
for (let car of cars) {
  if (car.color !== "black") {
    continue; // пропускаем машины не чёрного цвета
  }
  if (car.year >= 2020) {
    console.log("Можно рассмотреть:", car);
  }
}
```  
Вывод:
```
Можно рассмотреть: { model: 'Peugeot', make: '208', year: 2021, color: 'black' }
Можно рассмотреть: { model: 'Fiat', make: 'Punto', year: 2020, color: 'black' }
```  

### Осторожно: `continue` в `while`

В циклах `while` `continue` может привести к бесконечному циклу, если не обновлять переменные перед ним:

❌ **Плохо:**
```javascript
let i = 1;
while (i < 50) {
  if (i % 2 === 0) {
    continue; // i не увеличивается, цикл зависает
  }
  console.log(i);
  i++;
}
```  

✅ **Лучше:**
```javascript
for (let i = 1; i < 50; i += 2) {
  console.log(i); // выводим только нечётные числа
}
```  

## `break` и `continue` во вложенных циклах

Эти операторы работают только внутри текущего цикла. Чтобы выйти из внешнего цикла, можно использовать **метки**.

### Поиск группы с двумя именами на "M"

```javascript
let groups = [
  ["Martin", "Daniel", "Keith"],
  ["Margot", "Marina", "Ali"],
  ["Helen", "Jonah", "Sambikos"]
];

for (let i = 0; i < groups.length; i++) {
  let matches = 0;
  for (let j = 0; j < groups[i].length; j++) {
    if (groups[i][j].startsWith("M")) {
      matches++;
    } else {
      continue;
    }
    if (matches === 2) {
      console.log("Группа с двумя именами на 'M':", groups[i]);
      break; // выходим из внутреннего цикла
    }
  }
}
```  

### Использование меток для выхода из внешнего цикла

```javascript
outerLoop:
for (let group of groups) {
  for (let member of group) {
    if (member.startsWith("M")) {
      console.log("Первое имя на 'M':", member);
      break outerLoop; // выход из обоих циклов
    }
  }
}
```  
Вывод:
```
Первое имя на 'M': Martin
```  
