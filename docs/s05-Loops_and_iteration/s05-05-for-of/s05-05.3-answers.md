# Ответы для "Цикл `for...of`"

1. **Ответ:** Цикл `for...of`.  
   **Пояснение:** Он предназначен для перебора значений массива без изменения его структуры или элементов.

2. **Ответ:** `for (let variable of iterable) { ... }`.  
   **Пояснение:** Пример:
```javascript  
for (let num of [1, 2, 3]) {  
  console.log(num);  
}  
```  

3. **Ответ:** `for` требует ручного управления индексом, а `for...of` автоматически перебирает значения.  
   **Пояснение:** В `for` нужно указывать счётчик (`i++`), а `for...of` сразу даёт доступ к элементам.

4. **Ответ:** Нет, нельзя напрямую изменять исходный массив.  
   **Пояснение:** `for...of` даёт доступ только к значению на текущей итерации, но не к индексу для модификации.

5. **Ответ:**
```javascript  
const arr = [10, 20, 30];  
for (let item of arr) {  
  console.log(item);  
}  
```  
**Пояснение:** На каждой итерации `item` принимает значение следующего элемента.

6. **Ответ:** Да, можно. Пример:
```javascript  
for (let char of "Hello") {  
  console.log(char);  
}  
```  
**Пояснение:** Строка — итерируемый объект, поэтому `for...of` выводит каждый символ.

7. **Ответ:** `for...of` перебирает значения, а `for...in` — ключи (индексы).  
   **Пояснение:** `for...in` может зацепить лишние свойства, если массив был расширен.

8. **Ответ:** Потому что он перебирает все перечисляемые свойства, включая добавленные вручную.  
   **Пояснение:** Например, если добавить свойство `arr.test = 5`, `for...in` его выведет.

9. **Ответ:** Через метод `entries()`:
```javascript  
for (const [index, value] of arr.entries()) { ... }  
```  
**Пояснение:** `entries()` возвращает пары `[индекс, значение]`.

10. **Ответ:** Да, если переменная не изменяется в цикле.  
    **Пояснение:** `const` подходит, так как на каждой итерации создаётся новая переменная.

11. **Ответ:** Строки, `Set`, `Map`, `NodeList` и другие итерируемые объекты.  
    **Пояснение:** Главное условие — объект должен иметь итератор.

12. **Ответ:** Простота, читаемость и отсутствие риска бесконечного цикла.  
    **Пояснение:** Не нужно следить за индексами, как в `for` или `while`.

13. **Ответ:** Нельзя менять массив, нет доступа к индексу без `entries()`, не работает с обычными объектами.  
    **Пояснение:** Для объектов используйте `for...in` или `Object.keys()`.

14. **Ответ:** `for...of` — для чтения значений, `for` — для изменения или сложной логики с индексами.  
    **Пояснение:** Например, для удаления элементов нужен обычный `for`.

15. **Ответ:**
```javascript  
for (let num of [1, 2, 3, 4]) {  
  if (num % 2 === 0) console.log(num);  
}  
```  
**Пояснение:** Условие `num % 2 === 0` фильтрует чётные числа.

16. **Ответ:** Нет, потому что объекты не являются итерируемыми по умолчанию.  
    **Пояснение:** Для объектов используйте `for...in` или `Object.entries()`.

17. **Ответ:** Метод `entries()`.  
    **Пояснение:** Он преобразует массив в итерируемый объект с парами `[индекс, значение]`.

18. **Ответ:**
```  
6  
11  
16  
```  
**Пояснение:** На каждой итерации к элементу массива добавляется `1`.

19. **Ответ:** Обычный `for` или `forEach()`.  
    **Пояснение:** Они позволяют обращаться к индексам и изменять элементы.

20. **Ответ:** Пример с `Set`:
```javascript  
const set = new Set([1, 2, 3]);  
for (let item of set) {  
  console.log(item);  
}  
```  
**Пояснение:** `Set` — итерируемый объект, поэтому `for...of` работает.
