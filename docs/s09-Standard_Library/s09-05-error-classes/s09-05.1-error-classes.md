# Обработка ошибок в JavaScript

JavaScript использует механизм исключений для обработки ошибок, основанный на операторах `throw` и `try/catch`. Важной особенностью языка является то, что эти операторы могут работать с любыми значениями — как примитивами (строками, числами), так и объектами. Однако существует общепринятая практика использовать специальные объекты ошибок, которые предоставляют больше информации об ошибке.

## Базовый класс Error

Класс `Error` — это стандартный способ создания объектов ошибок в JavaScript. Его основное преимущество заключается в том, что при создании такого объекта автоматически захватывается текущее состояние стека вызовов, что критически важно для отладки.

### Создание и использование Error

```javascript
// Простейшее создание ошибки
const error = new Error("Сообщение об ошибке");

// Выбрасывание ошибки
throw new Error("Что-то пошло не так");
```

### Свойства объекта Error

- **message**: строка с описанием ошибки, переданная в конструктор
- **name**: имя ошибки (по умолчанию "Error")
- **stack** (нестандартное, но широко поддерживаемое): содержит трассировку стека

```javascript
try {
    throw new Error("Тестовая ошибка");
} catch (error) {
    console.error(error.name);    // "Error"
    console.error(error.message); // "Тестовая ошибка"
    console.error(error.stack);   // Stack trace
}
```

## Важность создания Error перед выбрасыванием

Всегда создавайте объект Error непосредственно перед оператором `throw`:

```javascript
// Правильно
throw new Error("Ошибка загрузки данных");

// Неправильно - теряется контекст стека
const error = new Error("Ошибка загрузки данных");
// ... какой-то код ...
throw error;
```

Стек трассировки показывает место создания Error объекта, а не место его выбрасывания.

## Стандартные подклассы Error

JavaScript определяет несколько встроенных подклассов для конкретных типов ошибок:

### TypeError
Возникает когда операция не может быть выполнена из-за несовместимого типа данных.

```javascript
const obj = null;
try {
    obj.someMethod(); // TypeError: Cannot read properties of null
} catch (error) {
    if (error instanceof TypeError) {
        console.error("Ошибка типа:", error.message);
    }
}
```

### ReferenceError
Происходит при обращении к несуществующей переменной.

```javascript
try {
    someUndefinedVariable; // ReferenceError
} catch (error) {
    if (error instanceof ReferenceError) {
        console.error("Ссылка на несуществующую переменную");
    }
}
```

### RangeError
Возникает когда значение выходит за допустимый диапазон.

```javascript
try {
    const array = new Array(-1); // RangeError
} catch (error) {
    if (error instanceof RangeError) {
        console.error("Недопустимый диапазон");
    }
}
```

### SyntaxError
Ошибка синтаксиса (обычно возникает при eval или парсинге).

```javascript
try {
    eval("неправильный JS код"); // SyntaxError
} catch (error) {
    if (error instanceof SyntaxError) {
        console.error("Синтаксическая ошибка");
    }
}
```

### EvalError
Связана с неправильным использованием функции eval().

### URIError
Возникает при неправильном использовании функций работы с URI.

## Создание пользовательских классов ошибок

Для лучшей организации кода рекомендуется создавать собственные классы ошибок, наследующие от Error.

### Базовый пользовательский класс ошибки

```javascript
class ValidationError extends Error {
    constructor(message, field) {
        super(message);
        this.name = "ValidationError";
        this.field = field;
        this.timestamp = new Date();
    }
    
    toString() {
        return `${this.name} [${this.timestamp.toISOString()}]: ${this.message} (field: ${this.field})`;
    }
}

// Использование
throw new ValidationError("Неверный формат email", "email");
```

### Расширенный пример с HTTP ошибками

```javascript
class HTTPError extends Error {
    constructor(status, statusText, url, details = {}) {
        super(`${status} ${statusText}: ${url}`);
        this.status = status;
        this.statusText = statusText;
        this.url = url;
        this.details = details;
        this.name = "HTTPError";
    }
    
    get isClientError() {
        return this.status >= 400 && this.status < 500;
    }
    
    get isServerError() {
        return this.status >= 500;
    }
    
    toJSON() {
        return {
            name: this.name,
            status: this.status,
            statusText: this.statusText,
            url: this.url,
            message: this.message,
            details: this.details
        };
    }
}

// Использование
try {
    // Симуляция HTTP запроса
    throw new HTTPError(404, "Not Found", "https://api.example.com/users/123", {
        requestId: "abc-123",
        method: "GET"
    });
} catch (error) {
    if (error instanceof HTTPError) {
        console.error(`HTTP Error ${error.status}:`, error.message);
        console.error("URL:", error.url);
        console.error("Is client error?", error.isClientError);
        
        // Логирование в формате JSON
        console.error(JSON.stringify(error, null, 2));
    }
}
```

## Практические паттерны обработки ошибок

### Дифференцированная обработка ошибок

```javascript
function handleError(error) {
    if (error instanceof HTTPError) {
        // Обработка HTTP ошибок
        if (error.status === 404) {
            showUserMessage("Ресурс не найден");
        } else if (error.status === 500) {
            showUserMessage("Ошибка сервера, попробуйте позже");
            logErrorToService(error);
        }
    } else if (error instanceof ValidationError) {
        // Обработка ошибок валидации
        highlightErrorField(error.field);
        showValidationMessage(error.message);
    } else if (error instanceof TypeError) {
        // Обработка ошибок типа
        logErrorToService(error);
        showUserMessage("Внутренняя ошибка приложения");
    } else {
        // Обработка неизвестных ошибок
        logErrorToService(error);
        showUserMessage("Неизвестная ошибка");
    }
}
```

### Централизованный обработчик ошибок

```javascript
class ErrorHandler {
    static handle(error, context = "general") {
        // Логирование
        this.logError(error, context);
        
        // Пользовательский интерфейс
        this.showUserFriendlyMessage(error);
        
        // Отправка в сервис мониторинга
        this.reportToMonitoringService(error, context);
    }
    
    static logError(error, context) {
        const logEntry = {
            timestamp: new Date(),
            context,
            name: error.name,
            message: error.message,
            stack: error.stack,
            // Дополнительные свойства для кастомных ошибок
            ...error
        };
        
        console.error("Ошибка:", logEntry);
    }
    
    static showUserFriendlyMessage(error) {
        // Преобразование технических ошибок в понятные пользователю сообщения
        const message = this.getUserMessage(error);
        displayNotification(message, "error");
    }
    
    static getUserMessage(error) {
        if (error instanceof HTTPError) {
            switch (error.status) {
                case 404: return "Запрашиваемый ресурс не найден";
                case 500: return "Внутренняя ошибка сервера";
                default: return "Ошибка соединения с сервером";
            }
        }
        // ... другие преобразования
        return "Произошла непредвиденная ошибка";
    }
}

// Использование
try {
    // Код, который может выбросить ошибку
} catch (error) {
    ErrorHandler.handle(error, "userProfileLoading");
}
```

## Рекомендации

1. **Всегда используйте Error объекты** вместо примитивов для лучшей отладки
2. **Создавайте ошибки непосредственно перед throw** для сохранения контекста стека
3. **Используйте соответствующие подклассы** для разных типов ошибок
4. **Добавляйте контекстную информацию** в пользовательские классы ошибок
5. **Реализуйте дифференцированную обработку** ошибок разных типов
6. **Предоставляйте пользовательские сообщения** отдельно от технических деталей
7. **Логируйте полную информацию** об ошибках для последующего анализа

Правильная обработка ошибок — критически важный аспект разработки надежных JavaScript приложений. Использование классов Error и их подклассов позволяет не только получать детальную информацию для отладки, но и создавать структурированную систему обработки различных типов исключительных ситуаций. Создание собственных классов ошибок, специфичных для вашего приложения, значительно улучшает читаемость кода и упрощает maintenance проекта.
