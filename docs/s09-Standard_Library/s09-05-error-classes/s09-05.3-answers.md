# Список ответов для "Обработка ошибок в JavaScript"

Конечно, вот правильные ответы на вопросы с краткими пояснениями.

1.  Любые значения JavaScript: примитивы (строки, числа, boolean, null, undefined, символы) и объекты.
    Пояснение: Механизм `throw` и `catch` в JS универсален и не требует обязательного использования объектов какого-либо特定ного класса.

2.  Потому что при создании объекта `Error` автоматически захватывается состояние стека вызовов, что помогает в отладке.
    Пояснение: Стек вызовов, доступный в свойстве `stack`, показывает цепочку функций, которая привела к ошибке, что невозможно при использовании простой строки.

3.  В момент создания объекта `Error` фиксируется (capture) текущее состояние стека вызовов.
    Пояснение: Именно поэтому объект ошибки нужно создавать непосредственно перед `throw`, чтобы стек трейс был максимально точным и указывал на настоящее место ошибки.

4.  `message` и `name`.
    Пояснение: `message` содержит описание ошибки, переданное в конструктор, а `name` — имя типа ошибки (по умолчанию "Error").

5.  Строку в формате `"name: message"`.
    Пояснение: Например, для `new Error('Не найдено')` метод `toString()` вернет `"Error: Не найдено"`.

6.  Нет, свойство `stack` не является частью стандарта ECMAScript. Оно поддерживается во всех современных браузерах и среде Node.js.
    Пояснение: Это нестандартное, но де-факто универсальное свойство, которое всегда следует использовать для логирования и отладки.

7.  Для отладки, так как оно содержит трассировку стека (stack trace) — список вызовов функций, которые привели к моменту создания ошибки.
    Пояснение: Это свойство не предназначено для показа пользователям, а служит разработчикам для понимания, где и почему произошла ошибка.

8.  EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError.
    Пояснение: Эти встроенные классы используются движком JavaScript для сигнализации об определенных типах ошибок. Мы также можем использовать их в своем коде.

9.  Когда значение выходит за пределы допустимого диапазона.
    Пояснение: Классический пример — создание массива отрицательной длины: `new Array(-1)`.

10. Когда операция выполнена над значением неожиданного или несовместимого типа.
    Пояснение: Например, попытка вызвать `null` как функцию: `null()` или обратиться к свойству `undefined`.

11. Это позволяет лучше инкапсулировать и структурировать ошибки, специфичные для предметной области приложения, и обрабатывать их точечно.
    Пояснение: Вместо разбора строк в `message` можно проверять тип ошибки оператором `instanceof` и обращаться к ее специфическим свойствам.

12. Любые свойства, несущие дополнительную информацию об ошибке: код ошибки, статус, метка времени, идентификатор запроса, детали валидации и т.д.
    Пояснение: Это мощный механизм для передачи контекста ошибки из места ее возникновения в место обработки.

13. Потому что свойство `stack` формируется в момент создания объекта, а не в момент его выбрасывания. Создание заранее приведет к неверному stack trace.
    Пояснение: Если создать ошибку в одной функции, а бросить в другой, стек трейс укажет на первую функцию, что запутает при отладке.

14. С помощью ключевого слова `super()`, передав в него строку сообщения.
    Пояснение: Вызов `super(message)` в конструкторе потомка гарантирует, что свойство `message` родительского класса `Error` будет инициализировано правильно.

15. Строку, сформированную из шаблона `${status} ${statusText}: ${url}`.
    Пояснение: В примере `new HTTPError(404, "Not Found", "http://example.com/")` свойство `message` будет равно `"404 Not Found: http://example.com/"`.

16. С помощью оператора `instanceof` (например, `if (error instanceof HTTPError) { ... }`).
    Пояснение: Это предпочтительный способ проверки типа ошибки, так как он надежен и работает с наследованием.

17. Используя конструкцию `try/catch` с последующими условиями `if` или `switch` и оператором `instanceof` для проверки типа пойманной ошибки.
    Пояснение: Это позволяет по-разному реагировать на сетевые ошибки, ошибки валидации, логические ошибки и т.д.

18. Пользователю следует показывать понятное сообщение о том, что произошло и что делать дальше. Логировать для разработчика нужно всю техническую информацию: имя ошибки, сообщение, stack trace и все дополнительные свойства.
    Пояснение: Технические детали и stack trace могут содержать внутреннюю информацию о системе, которую небезопасно показывать пользователю.

19. Можно создать отдельный модуль или класс (например, `ErrorHandler`), который будет получать все пойманные ошибки и в одном месте заниматься их логированием, преобразованием в пользовательские сообщения и отправкой на сервер мониторинга.
    Пояснение: Это делает код обработки ошибок согласованным, избегает дублирования и упрощает его изменение.

20. Всегда использовать `Error` или его подклассы; создавать ошибку прямо перед `throw`; использовать встроенные подклассы для соответствующих случаев; создавать собственные классы для ошибок предметной области; добавлять контекстные свойства в ошибки; централизованно обрабатывать и логировать ошибки.
    Пояснение: Следование этим практикам делает код более надежным, удобным для отладки и поддержки.
