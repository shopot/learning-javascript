# Работа с датами и временем в JavaScript

Одной из ключевых возможностей любого языка программирования является работа с датами и временем. В JavaScript за эту функциональность отвечает встроенный класс `Date`. Это ваш главный инструмент для создания, управления, форматирования и анализа временных данных.

## Создание объекта Date

Объект `Date` создается с помощью конструктора `new Date()`. Существует несколько способов его вызова, каждый из которых определяет начальное значение даты.

**1. Текущая дата и время**
Самый простой и частый способ — вызвать конструктор без аргументов. В результате вы получите объект `Date`, представляющий точный момент времени на момент его создания.

```javascript
let now = new Date(); // Сохраняет текущие дату и время
console.log(now); // Выведет что-то вроде: Tue Aug 21 2024 14:35:00 GMT+0300
```

**2. Создание из timestamp (метки времени)**
Можно создать дату, передав один числовой аргумент. Этот аргумент интерпретируется как количество миллисекунд, прошедших с полуночи 1 января 1970 года по UTC (этот момент называется «Эпохой Unix» или «Юникс-временем»).

```javascript
let epoch = new Date(0); // Точка отсчета: 1970-01-01T00:00:00.000Z
let nextDay = new Date(24 * 60 * 60 * 1000); // +1 день: 1970-01-02T00:00:00.000Z
```

**3. Создание из компонентов (год, месяц, день, ...)**
Передача двух и более целочисленных аргументов позволяет создать дату, указав её компоненты в местном часовом поясе (часовом поясе компьютера, на котором запущен код).

Порядок аргументов: `год`, `месяц`, `день`, `часы`, `минуты`, `секунды`, `миллисекунды`. Все аргументы, начиная с дня, являются опциональными и по умолчанию равны 0.

```javascript
// 1 января 2100 года, 02:03:04.005 по местному времени
let century = new Date(2100, 0, 1, 2, 3, 4, 5);
```

**Важная особенность:** Месяцы в JavaScript отсчитываются с нуля.
*   `0` — январь
*   `1` — февраль
*   ...
*   `11` — декабрь

Дни месяца, в отличие от месяцев, отсчитываются с единицы (как и в календаре).

**4. Создание даты в UTC**
Если вам нужно создать дату не в местном часовом поясе, а в UTC (Всемирное координированное время, раньше известное как GMT), используйте статический метод `Date.UTC()`. Он принимает те же аргументы, что и конструктор `Date`, но возвращает не объект, а timestamp. Этот timestamp затем можно передать обратно в конструктор `Date`.

```javascript
// Создает timestamp для полуночи 1 января 2100 года по UTC
let utcTimestamp = Date.UTC(2100, 0, 1);
// Создает объект Date из этого timestamp
let centuryUTC = new Date(utcTimestamp);
// Можно записать в одну строку:
let centuryUTC = new Date(Date.UTC(2100, 0, 1));
```

**5. Создание из строки**
Конструктор `Date` может пытаться распарсить строку, если она передана в качестве аргумента. Он понимает несколько форматов, в том числе строки, возвращаемые методами `toISOString()`, `toUTCString()` и `toString()`.

Наиболее надежный и стандартизированный формат — ISO 8601 (например, `YYYY-MM-DDTHH:mm:ss.sssZ`).

```javascript
let dateFromString = new Date("2025-03-15T12:30:45Z"); // 15 марта 2025, 12:30:45 по UTC
let anotherDate = new Date("March 15, 2025 12:30:45"); // Нестандартный формат, может работать не во всех средах
```

**Внимание:** Парсинг строк, не соответствующих стандартным форматам, может работать непредсказуемо и зависеть от реализации в браузере или Node.js. Всегда предпочитайте использовать числовые аргументы или формат ISO 8601.

## Получение и установка компонентов даты

После создания объекта `Date` вы можете получать и изменять его отдельные компоненты (год, месяц, день и т.д.). Для каждого компонента существует два набора методов: один для работы в местном часовом поясе, другой — в UTC.

*   `getFullYear()` / `setFullYear(year)` — год (4 цифры).
*   `getMonth()` / `setMonth(month)` — месяц (0-11).
*   `getDate()` / `setDate(day)` — день месяца (1-31).
*   `getHours()` / `setHours(hours)` — часы (0-23).
*   `getMinutes()` / `setMinutes(minutes)` — минуты (0-59).
*   `getSeconds()` / `setSeconds(seconds)` — секунды (0-59).
*   `getMilliseconds()` / `setMilliseconds(milliseconds)` — миллисекунды (0-999).

UTC-версии этих методов имеют префикс `UTC`: `getUTCFullYear()`, `setUTCFullYear(year)` и т.д.

```javascript
let d = new Date(); // Текущая дата
let year = d.getFullYear(); // Получить текущий год
d.setFullYear(year + 1); // Увеличить год на 1 (установить следующий год)

let utcHours = d.getUTCHours(); // Получить текущий час в UTC
```

**Отдельно стоит выделить методы для дня недели:**
*   `getDay()` / `getUTCDay()` — возвращает день недели (0 для воскресенья, 1 для понедельника, ..., 6 для субботы). Это только геттеры, сеттеров для дня недели не существует.

Некоторые сеттеры позволяют установить несколько полей сразу. Например, `setFullYear(year, month?, day?)` и `setHours(hours, minutes?, seconds?, ms?)`.

## Метки времени (Timestamps) и измерение времени

В основе любого объекта `Date` лежит целое число — количество миллисекунд, прошедших с Эпохи Unix (1 января 1970, UTC). Это число называется **timestamp** или **меткой времени**.

*   `getTime()` — возвращает этот timestamp.
*   `setTime(timestamp)` — устанавливает дату, используя переданный timestamp.

Это очень полезно для простых арифметических операций с датами, например, для добавления 30 секунд:

```javascript
let d = new Date();
d.setTime(d.getTime() + 30000); // Прибавляет 30 000 мс (30 секунд)
```

Для удобства измерения промежутков времени существует статический метод `Date.now()`, который возвращает текущий timestamp. Это идеальный способ засечь время выполнения операции.

```javascript
let startTime = Date.now(); // Засекаем начальное время

// Здесь код, время выполнения которого мы хотим измерить
for (let i = 0; i < 1000000; i++) { /* какая-то работа */ }

let endTime = Date.now(); // Засекаем конечное время
console.log(`Операция заняла ${endTime - startTime} миллисекунд.`);
```

**Высокоточные таймеры (performance.now())**

В веб-браузерах и Node.js доступен более точный механизм измерения времени через API `performance`. Метод `performance.now()` возвращает метку времени с высокой точностью (включая дробную часть миллисекунды), но его значение показывает не абсолютное время, а время, прошедшее с момента загрузки страницы (в браузере) или запуска процесса (в Node.js). Это лучше подходит для бенчмаркинга.

```javascript
// В браузере performance доступен глобально
let startPerf = performance.now();
// ... выполняемый код ...
let endPerf = performance.now();
console.log(`Высокоточное измерение: ${endPerf - startPerf} мс.`);

// В Node.js нужно импортировать performance
const { performance } = require('perf_hooks');
```

## Арифметика с датами

Объекты `Date` можно сравнивать с помощью операторов `<`, `<=`, `>`, `>=`.

Вычитание двух объектов `Date` возвращает разницу между ними в миллисекундах. Это работает, потому что объекты `Date` автоматически преобразуются в свои timestamp при численных операциях.

```javascript
let date1 = new Date(2025, 0, 1);
let date2 = new Date(2025, 0, 15);
let differenceInMs = date2 - date1; // Разница в миллисекундах
let differenceInDays = differenceInMs / (1000 * 60 * 60 * 24); // ~14 дней
console.log(differenceInDays); // 14
```

Для добавления или вычитания дней, месяцев или лет лучше использовать специальные сеттеры, так как они корректно обрабатывают переполнения (например, переход через конец месяца или високосный год).

```javascript
let d = new Date();
d.setMonth(d.getMonth() + 3); // Добавить 3 месяца к текущей дате
d.setDate(d.getDate() + 14); // Добавить 14 дней

// Можно комбинировать (добавить 3 месяца и 14 дней)
d.setMonth(d.getMonth() + 3, d.getDate() + 14);
```

## Форматирование и парсинг строк

Класс `Date` предоставляет несколько методов для преобразования в строку.

```javascript
let d = new Date(2025, 2, 15, 14, 30, 45); // 15 марта 2025, 14:30:45

// Основные методы:
d.toString();        // "Sat Mar 15 2025 14:30:45 GMT+0300 (Москва, стандартное время)" - местный час. пояс
d.toUTCString();     // "Sat, 15 Mar 2025 11:30:45 GMT" - UTC
d.toISOString();     // "2025-03-15T11:30:45.000Z" - Стандартный ISO формат (UTC)
d.toDateString();    // "Sat Mar 15 2025" - только дата
d.toTimeString();    // "14:30:45 GMT+0300 (Москва, стандартное время)" - только время

// Локализованные методы (зависят от настроек пользователя):
d.toLocaleDateString(); // "15.03.2025" (формат зависит от локали)
d.toLocaleTimeString(); // "14:30:45" (формат зависит от локали)
d.toLocaleString();     // "15.03.2025, 14:30:45" (и дата, и время)
```

**Какой метод выбрать?**
*   Для хранения или передачи даты на сервер идеально подходит `toISOString()`.
*   Для показа даты пользователю лучше использовать локализованные методы (`toLocaleDateString()`, `toLocaleTimeString()`), так как они форматируют дату согласно региональным стандартам его системы.

Для обратной операции — преобразования строки в дату — используется статический метод `Date.parse()`. Он пытается распарсить строку и в случае успеха возвращает соответствующий timestamp. Этот метод понимает те же форматы, что и конструктор `new Date(string)`.

```javascript
let timestamp = Date.parse("2025-03-15T11:30:45.000Z");
if (!isNaN(timestamp)) { // Всегда проверяйте результат на валидность!
  let parsedDate = new Date(timestamp);
  console.log(parsedDate);
}
```

## Заключение

Класс `Date` в JavaScript — это мощный, хотя и имеющий некоторые peculiarities (например, нумерация месяцев с 0), инструмент для работы со временем. Понимание разницы между местным временем и UTC, а также умение использовать timestamp для арифметики и измерений являются ключевыми для эффективной работы с датами. Для пользовательского интерфейса всегда отдавайте предпочтение локализованным методам форматирования.
