# Коллекции Set и Map

До появления стандарта ES6 разработчики часто использовали обычные объекты JavaScript для создания структур данных, похожих на множества (sets) и словари (maps). Однако у этого подхода есть существенные ограничения:

- Ключи объектов могут быть только строками (или Symbol)
- Объекты имеют унаследованные свойства (например, `toString`), которые могут мешать
- Нет удобных методов для работы с коллекциями

ES6 представил настоящие классы `Set` и `Map`, которые решают эти проблемы и предоставляют мощные инструменты для работы с коллекциями данных.

## Класс Set

### Что такое Set?

Set (множество) — это коллекция уникальных значений. В отличие от массивов, множества:
- Не имеют индексов и порядка элементов (хотя на практике порядок добавления сохраняется)
- Не позволяют иметь дубликаты — значение может быть в множестве только один раз

### Создание Set

Создать множество можно с помощью конструктора `Set()`:

```javascript
// Пустое множество
let emptySet = new Set();

// Множество из массива значений
let numbersSet = new Set([1, 2, 3, 4, 5]);

// Множество из строки (будет содержать уникальные символы)
let uniqueChars = new Set("Mississippi"); // {'M', 'i', 's', 'p'}
```

Конструктор `Set()` может принимать любой итерируемый объект, включая другие множества.

### Свойство size

Свойство `size` возвращает количество элементов в множестве:

```javascript
let fruits = new Set(['apple', 'banana', 'orange']);
console.log(fruits.size); // 3
```

### Основные методы Set

#### add() — добавление элемента

Добавляет элемент в множество. Если элемент уже существует, ничего не происходит:

```javascript
let set = new Set();
set.add(1);
set.add(2);
set.add(1); // Дубликат не добавится

console.log(set.size); // 2
```

Метод `add()` возвращает сам Set, что позволяет делать цепочки вызовов:

```javascript
let set = new Set().add('a').add('b').add('c');
```

#### has() — проверка наличия элемента

Проверяет, существует ли элемент в множестве:

```javascript
let colors = new Set(['red', 'green', 'blue']);
console.log(colors.has('red')); // true
console.log(colors.has('yellow')); // false
```

#### delete() — удаление элемента

Удаляет элемент из множества. Возвращает `true`, если элемент был удален, и `false`, если его не было:

```javascript
let animals = new Set(['cat', 'dog', 'bird']);
console.log(animals.delete('dog')); // true
console.log(animals.delete('fish')); // false
console.log(animals.size); // 2
```

#### clear() — очистка множества

Полностью очищает множество:

```javascript
let set = new Set([1, 2, 3]);
set.clear();
console.log(set.size); // 0
```

### Особенности сравнения значений

Set использует строгое сравнение (`===`) для определения уникальности значений:

```javascript
let set = new Set();
set.add(1);      // число 1
set.add("1");    // строка "1" — это другое значение
set.add({});     // объект
set.add({});     // другой объект (даже с таким же содержимым)

console.log(set.size); // 4
```

Объекты и массивы сравниваются по ссылке, а не по содержимому:

```javascript
let obj = {x: 1};
let set = new Set();
set.add(obj);
set.add({x: 1}); // это другой объект

console.log(set.size); // 2
console.log(set.has(obj)); // true
console.log(set.has({x: 1})); // false (другой объект)
```

### Итерация по Set

Set является итерируемым объектом, поэтому можно использовать цикл `for...of`:

```javascript
let fruits = new Set(['apple', 'banana', 'orange']);

for (let fruit of fruits) {
    console.log(fruit);
}
// apple
// banana
// orange
```

Также можно преобразовать Set в массив с помощью оператора расширения (`...`):

```javascript
let set = new Set([1, 2, 3]);
let array = [...set]; // [1, 2, 3]

// Или использовать Array.from()
let array2 = Array.from(set); // [1, 2, 3]
```

### Метод forEach()

Set имеет метод `forEach()`, аналогичный массивам:

```javascript
let numbers = new Set([1, 2, 3, 4, 5]);

numbers.forEach((value, valueAgain, set) => {
    console.log(value);
});
```

Обратите внимание, что в колбек `forEach()` для Set передаются три параметра:
1. Значение элемента
2. То же значение again (для совместимости с Map)
3. Сам Set

### Порядок элементов в Set

В отличие от математического множества, JavaScript Set сохраняет порядок добавления элементов. При итерации элементы возвращаются в том порядке, в котором они были добавлены.

## Класс Map

### Что такое Map?

Map (словарь, отображение) — это коллекция пар ключ-значение. В отличие от объектов:
- Ключами могут быть любые значения (включая объекты)
- Сохраняется порядок добавления элементов
- Есть удобные методы для работы с коллекцией
- Нет унаследованных свойств

### Создание Map

Создать словарь можно с помощью конструктора `Map()`:

```javascript
// Пустой словарь
let emptyMap = new Map();

// Словарь из массива пар [ключ, значение]
let userMap = new Map([
    ['name', 'John'],
    ['age', 30],
    ['isAdmin', true]
]);
```

Конструктор `Map()` может принимать любой итерируемый объект, содержащий пары ключ-значение.

### Свойство size

Свойство `size` возвращает количество элементов в словаре:

```javascript
let map = new Map([['a', 1], ['b', 2]]);
console.log(map.size); // 2
```

### Основные методы Map

#### set() — установка значения

Устанавливает значение по ключу. Если ключ уже существует, значение обновляется:

```javascript
let map = new Map();
map.set('name', 'Alice');
map.set('age', 25);
map.set('name', 'Bob'); // Обновляем значение

console.log(map.get('name')); // 'Bob'
```

Метод `set()` возвращает сам Map, что позволяет делать цепочки вызовов:

```javascript
let map = new Map()
    .set('a', 1)
    .set('b', 2)
    .set('c', 3);
```

#### get() — получение значения

Возвращает значение по ключу. Если ключа нет, возвращает `undefined`:

```javascript
let map = new Map([['fruit', 'apple'], ['color', 'red']]);
console.log(map.get('fruit')); // 'apple'
console.log(map.get('size')); // undefined
```

#### has() — проверка наличия ключа

Проверяет, существует ли ключ в словаре:

```javascript
let map = new Map([['x', 10], ['y', 20]]);
console.log(map.has('x')); // true
console.log(map.has('z')); // false
```

#### delete() — удаление элемента

Удаляет элемент по ключу. Возвращает `true`, если элемент был удален, и `false`, если его не было:

```javascript
let map = new Map([['a', 1], ['b', 2], ['c', 3]]);
console.log(map.delete('b')); // true
console.log(map.delete('d')); // false
console.log(map.size); // 2
```

#### clear() — очистка словаря

Полностью очищает словарь:

```javascript
let map = new Map([['a', 1], ['b', 2]]);
map.clear();
console.log(map.size); // 0
```

### Особенности использования ключей

Ключи в Map могут быть любого типа, включая объекты:

```javascript
let objKey = {id: 1};
let funcKey = function() {};

let map = new Map();
map.set(objKey, 'object value');
map.set(funcKey, 'function value');
map.set(null, 'null value');
map.set(undefined, 'undefined value');
map.set(NaN, 'NaN value');

console.log(map.get(objKey)); // 'object value'
console.log(map.get(null)); // 'null value'
console.log(map.get(NaN)); // 'NaN value'
```

Как и в Set, объекты сравниваются по ссылке, а не по содержимому:

```javascript
let map = new Map();
map.set({x: 1}, 'first object');
map.set({x: 1}, 'second object'); // Это другой объект!

console.log(map.size); // 2
```

### Итерация по Map

Map является итерируемым объектом. При итерации возвращаются пары `[ключ, значение]`:

```javascript
let user = new Map([
    ['name', 'John'],
    ['age', 30],
    ['isAdmin', true]
]);

for (let [key, value] of user) {
    console.log(`${key}: ${value}`);
}
// name: John
// age: 30
// isAdmin: true
```

Также можно преобразовать Map в массив:

```javascript
let map = new Map([['a', 1], ['b', 2]]);
let array = [...map]; // [['a', 1], ['b', 2]]
```

### Методы keys(), values(), entries()

Map предоставляет методы для получения итераторов по ключам, значениям и парам:

```javascript
let map = new Map([['a', 1], ['b', 2], ['c', 3]]);

// Ключи
console.log([...map.keys()]); // ['a', 'b', 'c']

// Значения
console.log([...map.values()]); // [1, 2, 3]

// Пары ключ-значение
console.log([...map.entries()]); // [['a', 1], ['b', 2], ['c', 3]]
```

### Метод forEach()

Map также имеет метод `forEach()`:

```javascript
let map = new Map([['a', 1], ['b', 2], ['c', 3]]);

map.forEach((value, key, map) => {
    console.log(`${key}: ${value}`);
});
// a: 1
// b: 2
// c: 3
```

Обратите внимание на порядок параметров: сначала значение, затем ключ.

### Порядок элементов в Map

Как и в Set, Map сохраняет порядок добавления элементов. При итерации элементы возвращаются в том порядке, в котором они были добавлены.

## WeakMap и WeakSet

### Проблема утечек памяти

В JavaScript есть автоматическое управление памятью (сборка мусора). Объект удаляется из памяти, когда на него больше нет ссылок. Однако обычные Map и Set хранят "сильные" ссылки на свои элементы, что может предотвратить удаление объектов сборщиком мусора.

### WeakMap

WeakMap — это особый вид Map, который:
- Ключами могут быть только объекты
- Хранит "слабые" ссылки на ключи (не предотвращают сборку мусора)
- Не поддерживает итерацию и метод `size`
- Имеет только методы: `get()`, `set()`, `has()`, `delete()`

```javascript
let weakMap = new WeakMap();
let obj = {};

weakMap.set(obj, 'secret value');
console.log(weakMap.get(obj)); // 'secret value'

obj = null; // Теперь объект может быть удален сборщиком мусора
```

### WeakSet

WeakSet — это особый вид Set, который:
- Может содержать только объекты
- Хранит "слабые" ссылки на элементы
- Не поддерживает итерацию и метод `size`
- Имеет только методы: `add()`, `has()`, `delete()`

```javascript
let weakSet = new WeakSet();
let obj1 = {};
let obj2 = {};

weakSet.add(obj1);
weakSet.add(obj2);

console.log(weakSet.has(obj1)); // true

obj1 = null; // Теперь объект может быть удален сборщиком мусора
```

### Use Cases для WeakMap и WeakSet

1. **Кеширование** — ассоциирование данных с объектами без предотвращения их удаления
2. **Счетчики ссылок** — отслеживание использования объектов
3. **Приватные данные** — хранение приватных данных объектов

Пример с кешированием:

```javascript
let cache = new WeakMap();

function process(obj) {
    if (!cache.has(obj)) {
        // Дорогостоящие вычисления
        let result = /* ... вычисления с obj ... */;
        cache.set(obj, result);
    }
    return cache.get(obj);
}
```

## Сравнение с объектами

### Когда использовать Object, а когда Map?

**Используйте Object, когда:**
- Ключи — строки или Symbol
- Нужен JSON-сериализация
- Работаете с небольшим количеством известных свойств

**Используйте Map, когда:**
- Ключи могут быть любого типа
- Важен порядок элементов
- Нужно часто добавлять/удалять элементы
- Неизвестно, сколько элементов будет заранее

### Когда использовать Array, а когда Set?

**Используйте Array, когда:**
- Важен порядок элементов (с индексами)
- Есть дубликаты
- Нужны методы для работы с массивами

**Используйте Set, когда:**
- Нужна гарантия уникальности значений
- Часто проверяете наличие элементов
- Часто добавляете/удаляете элементы

## Практические примеры

### Удаление дубликатов из массива

```javascript
let numbers = [1, 2, 3, 2, 4, 5, 1, 6];
let uniqueNumbers = [...new Set(numbers)];
console.log(uniqueNumbers); // [1, 2, 3, 4, 5, 6]
```

### Группировка данных

```javascript
let users = [
    {name: 'John', age: 20},
    {name: 'Jane', age: 20},
    {name: 'Bob', age: 30}
];

// Группировка по возрасту
let usersByAge = new Map();

for (let user of users) {
    if (!usersByAge.has(user.age)) {
        usersByAge.set(user.age, []);
    }
    usersByAge.get(user.age).push(user);
}

console.log(usersByAge.get(20)); // Массив с John и Jane
```

### Кеширование результатов функций

```javascript
let cache = new Map();

function expensiveOperation(n) {
    if (cache.has(n)) {
        return cache.get(n);
    }
    
    let result = /* ... дорогостоящие вычисления ... */;
    cache.set(n, result);
    return result;
}
```

## Заключение

Set и Map — это мощные структуры данных, которые дополняют обычные массивы и объекты. Они предоставляют лучшую производительность для определенных операций и более удобный API для работы с коллекциями.

- Используйте **Set** для работы с уникальными значениями
- Используйте **Map** для работы с парными данными, когда ключи могут быть любого типа
- Используйте **WeakMap** и **WeakSet** когда нужно ассоциировать данные с объектами без предотвращения сборки мусора
