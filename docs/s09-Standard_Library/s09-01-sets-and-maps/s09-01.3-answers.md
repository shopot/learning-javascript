# Список ответов по материалу "Коллекции Set и Map"

1. `Set` — это коллекция уникальных значений. В отличие от массива, `Set` не имеет индексов, не допускает дубликатов и хранит элементы в порядке их добавления.
2. С помощью конструктора `Set()` без аргументов: `let mySet = new Set();`
3. Передав массив в конструктор `Set()`: `let mySet = new Set([1, 2, 3]);`
4. Свойство `size`: `mySet.size` возвращает количество элементов.
5. Методом `add()`: `mySet.add('новый элемент');`
6. Ничего не произойдет, значение не добавится, так как `Set` хранит только уникальные значения.
7. Методом `has()`: `mySet.has(значение)` возвращает `true` или `false`.
8. Методом `delete()`: `mySet.delete(значение)`
9. `true` — если элемент был удален, `false` — если элемента не было в `Set`.
10. Методом `clear()`: `mySet.clear()`
11. По строгому равенству (как оператор `===`), включая сравнение объектов по ссылке.
12. Потому что объекты сравниваются по ссылке, а не по содержимому, даже если их свойства идентичны.
13. `for (let item of mySet) { console.log(item); }`
14. `let myArray = [...mySet];` или `let myArray = Array.from(mySet);`
15. `Map` — это коллекция пар ключ-значение. В отличие от объекта, ключами могут быть любые типы данных, включая объекты, и порядок элементов сохраняется.
16. С помощью конструктора `Map()` без аргументов: `let myMap = new Map();`
17. Передав массив массивов в конструктор: `let myMap = new Map([['key1', 'value1'], ['key2', 'value2']]);`
18. Свойство `size`: `myMap.size` возвращает количество элементов.
19. Методом `set()`: `myMap.set('ключ', 'значение');`
20. Методом `get()`: `myMap.get('ключ')` возвращает значение или `undefined`.
21. Методом `has()`: `myMap.has('ключ')` возвращает `true` или `false`.
22. Методом `delete()`: `myMap.delete('ключ')`
23. Методом `clear()`: `myMap.clear()`
24. Любые типы значений: примитивы, объекты, массивы, функции, `null`, `undefined`, `NaN`.
25. По строгому равенству (как оператор ===), включая сравнение объектов по ссылке.
26. `for (let [key, value] of myMap) { console.log(key, value); }`
27. `keys()` — для ключей, `values()` — для значений, `entries()` — для пар ключ-значение.
28. `WeakMap` хранит "слабые" ссылки на ключи-объекты, что позволяет сборщику мусора удалять их, и не препятствует этому.
29. `WeakMap` не поддерживает итерацию, не имеет метода `size`, и ключами могут быть только объекты.
30. Только объекты (не примитивы).
31. Потому что количество элементов может меняться в любой момент из-за работы сборщика мусора, что делает эти операции ненадежными.
32. `WeakSet` хранит "слабые" ссылки на объекты, позволяя сборщику мусора удалять их.
33. `WeakSet` не поддерживает итерацию, не имеет метода `size`, и значениями могут быть только объекты.
34. Для ассоциации дополнительных данных с объектами (кеширование, приватные данные) без создания утечек памяти.
35. `let uniqueArray = [...new Set(arrayWithDuplicates)];`
36. Когда нужны ключи нестрокового типа, важен порядок элементов или частые добавления/удаления.
37. Когда нужна гарантия уникальности значений и частые проверки наличия элемента.
38. Метод `forEach()`: `mySet.forEach(value => { ... });`
39. Метод `forEach()`: `myMap.forEach((value, key) => { ... });`
40. В порядке их добавления в коллекцию.

