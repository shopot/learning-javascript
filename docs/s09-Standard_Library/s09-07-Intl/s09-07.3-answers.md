# Ответы по теме "Internationalization API"

1. Intl.NumberFormat, Intl.DateTimeFormat и Intl.Collator.
   Эти три класса позволяют форматировать числа, даты и время, а также сравнивать строки с учетом региональных особенностей.

2. Internationalization API определяется стандартом ECMA402 и не является частью стандарта ECMAScript.
   Стандарт ECMAScript описывает ядро языка JavaScript, а ECMA402 — это отдельный стандарт для интернационализации.

3. Предсобранные бинарные файлы Node.js могут не содержать данных для локалей, кроме американского английского, и может потребоваться установка дополнительного пакета данных или создание кастомной сборки.
   Это связано с тем, что данные для локализаций имеют значительный объем и не всегда включаются в стандартную поставку Node.js.

4. `new Intl.NumberFormat('ru-RU').format(1234.56)`
   Конструктор Intl.NumberFormat принимает локаль первым аргументом, а метод format используется для применения форматирования к числу.

5. style, currency, currencyDisplay, useGrouping, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits.
   Эти свойства позволяют контролировать все аспекты форматирования чисел, от стиля (проценты, валюта) до точности отображаемых цифр.

6. `new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(1000)`
   Для форматирования валюты необходимо указать стиль "currency" и задать трехбуквенный код валюты в свойстве currency.

7. Свойство useGrouping определяет, использовать ли разделители тысяч (или их локальные эквиваленты).
   Если установлено значение false, числа будут форматироваться без разделителей разрядов.

8. `new Intl.NumberFormat(undefined, { style: 'percent', minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(0.123)`
   Стиль "percent" преобразует число в процентный формат, а свойства minimumFractionDigits и maximumFractionDigits контролируют количество знаков после запятой.

9. Можно присвоить метод format переменной и использовать его как самостоятельную функцию: `const format = new Intl.NumberFormat(...).format; format(123);`
   Метод format привязан (bound) к своему объекту, поэтому его можно использовать отдельно.

10. `new Intl.NumberFormat('ar', {useGrouping: false}).format(1234567890)`
    Локаль 'ar' (арабская) использует арабские цифры для представления чисел.

11. Это указание на использование системы числения деванагари (Devanagari numerals) через расширение Unicode.
    Префикс -u- указывает на расширение Unicode, nu — на систему числения, deva — конкретно на деванагари.

12. `new Intl.DateTimeFormat('en-US').format(date)` и `new Intl.DateTimeFormat('fr-FR').format(date)`
    Конструктор Intl.DateTimeFormat принимает локаль и возвращает объект, метод format которого форматирует переданный объект Date.

13. year, month, day, weekday, era, hour, minute, second, timeZone, timeZoneName, hour12, hourCycle.
    Эти свойства позволяют контролировать, какие компоненты даты и времени отображать и как их форматировать.

14. `new Intl.DateTimeFormat('en-US', { weekday: 'long', month: 'long', year: 'numeric', day: 'numeric' }).format(date)`
    Значения "long" для weekday и month обеспечивают полные названия дня недели и месяца.

15. Указав свойство timeZone в объекте настроек: `{ timeZone: 'America/New_York' }`
    В качестве значения можно использовать "UTC" или IANA идентификатор часового пояса.

16. Добавив расширение Unicode -u-ca- с названием календаря к локали: `new Intl.DateTimeFormat('en-u-ca-islamic', options)`
    Доступные календари: islamic, japanese, hebrew, buddhist и другие.

17. Intl.Collator предназначен для сравнения строк с учетом правил сортировки конкретного языка и региона.
    Он решает проблему корректной алфавитной сортировки, которая различается в разных языках.

18. `const collator = new Intl.Collator().compare;` и затем использовать `array.sort(collator)`
    Метод compare возвращает функцию, которую можно напрямую передать в метод sort массива.

19. "base" игнорирует регистр и акценты, рассматривая только базовую букву, а "variant" учитывает и регистр, и акценты, обеспечивая строгое сравнение.
    Чувствительность определяет, какие различия между символами считаются значимыми при сравнении.

20. Установив свойство numeric: true в настройках: `new Intl.Collator(undefined, { numeric: true }).compare`
    Это заставляет коллатор интерпретировать数字 в строках как числа, а не как последовательности цифр.

21. Используя чувствительность "base" и ignorePunctuation: true: `new Intl.Collator(undefined, { sensitivity: 'base', ignorePunctuation: true }).compare`
    Это позволяет находить совпадения, игнорируя акценты, регистр и пунктуацию.

22. Используя расширение Unicode -u-co-trad с локалью: `new Intl.Collator('es-ES-u-co-trad').compare`
    Это указывает на использование традиционного (trad) варианта сортировки (collation) для испанского языка в Испании.

23. Это указание на использование традиционного (traditional) варианта сортировки через расширение Unicode.
    Префикс -u- указывает на расширение Unicode, co — на вариант сортировки (collation), trad — конкретно на традиционный вариант.

24. Обеспечение корректного, соответствующего ожиданиям пользователя, отображения чисел, дат, валют и сортировки текста в зависимости от его региона и языка.
    Это улучшает пользовательский опыт и показывает уважение к культурным особенностям.

25. Потому что стандартная сортировка строк JavaScript использует порядок Unicode code points, который не соответствует алфавитному порядку во многих языках, в то время как Intl.Collator учитывает языковые правила.
    Например, в испанском языке "ch" и "ll" historically считались отдельными буквами, а в немецком умлауты имеют особые правила сортировки.
