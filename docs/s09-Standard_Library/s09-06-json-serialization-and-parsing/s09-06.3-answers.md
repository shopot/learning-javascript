# Список ответов по теме "JSON в JavaScript"

1.  Сериализация — это процесс преобразования сложных структур данных (объектов, массивов) в строку байт или символов для сохранения или передачи. Пояснение: Это нужно, чтобы данные можно было, например, записать в файл или отправить по сети, а затем восстановить их обратно в память.

2.  JSON расшифровывается как JavaScript Object Notation (нотация объектов JavaScript). Пояснение: Это текстовый формат для представления данных на основе синтаксиса объектов и массивов JavaScript.

3.  JSON поддерживает: числа, строки, логические значения (`true`, `false`), `null`, массивы и объекты. Пояснение: Это примитивные и структурированные типы, которые могут быть составлены из примитивов.

4.  JSON не поддерживает: `Map`, `Set`, `RegExp`, `Date`, типизированные массивы, функции и undefined. Пояснение: Эти специфические для JavaScript типы не входят в стандарт формата JSON.

5.  Две основные функции: `JSON.stringify()` для сериализации и `JSON.parse()` для десериализации. Пояснение: `stringify` преобразует объект в строку JSON, а parse преобразует строку JSON обратно в объект.

6.  Функция `JSON.stringify()` сериализует переданный объект в строку JSON. Пояснение: Она принимает значение, которое нужно преобразовать, и два необязательных аргумента для кастомизации процесса.

7.  Функция `JSON.parse()` парсит строку JSON, воссоздавая исходную структуру данных. Пояснение: Она принимает строку в формате JSON и необязательную функцию-reviver.

8.  Глубокую копию можно создать так: `JSON.parse(JSON.stringify(obj))`. Пояснение: Объект сериализуется в строку и сразу парсится обратно в новый, полностью независимый объект.

9.  Использовать eval() опасно, потому что он выполняет любой переданный код, что создает уязвимость для вредоносных скриптов. Пояснение: Злоумышленник может вставить в строку опасный код, который выполнится на вашей странице.

10. Два правила: все имена свойств должны быть в двойных кавычках, а комментарии запрещены. Пояснение: В JavaScript объекты можно создавать без кавычек для имен свойств и с комментариями, но в JSON это недопустимо.

11. Третий аргумент в `JSON.stringify()` управляет форматированием выходной строки. Пояснение: Он делает JSON "красивым" и читаемым для человека, добавляя пробелы или табуляцию для отступов.

12. Если передать число, оно определит количество пробелов для каждого уровня отступа. Пояснение: Например, число 2 добавит два пробела для каждого уровня вложенности.

13. Если передать строку (например, '\t'), она будет использоваться для отступа на каждом уровне. Пояснение: Символ табуляции сделает отступы более компактными, чем пробелы.

14. Нет, форматирование не влияет на `JSON.parse()`, он игнорирует все пробелы и переводы строк. Пояснение: Парсер анализирует только структуру данных, а не декоративные пробелы.

15. `JSON.stringify()` ищет у объекта метод toJSON(). Пояснение: Если метод существует, он вызывается, и его результат сериализуется вместо исходного объекта.

16. Объект Date имеет встроенный метод toJSON(), который возвращает строку в ISO-формате. Пояснение: Это эквивалентно вызову метода `toISOString()` у даты.

17. Функция-"оживитель" (reviver) — это необязательный аргумент для метода `JSON.parse()`. Пояснение: Она позволяет кастомизировать процесс парсинга, преобразовывая значения перед их добавлением в результат.

18. Функция-reviver принимает два аргумента: ключ (имя свойства) и значение. Пояснение: Она вызывается для каждой пары "ключ-значение" в процессе парсинга.

19. Чтобы удалить свойство, из функции-reviver нужно вернуть undefined. Пояснение: Это указание парсеру не добавлять данное свойство в финальный объект.

20. Функция-заместитель (replacer) — это необязательный аргумент для метода `JSON.stringify()`. Пояснение: Она позволяет фильтровать или преобразовывать значения перед их сериализацией.

21. Если передан массив строк, `JSON.stringify()` сериализует только те свойства, имена которых есть в массиве, и в указанном порядке. Пояснение: Это простой способ выбрать конкретные поля для сериализации и контролировать их порядок.

22. Сильная кастомизация жертвует портативностью и совместимостью с другими инструментами и языками. Пояснение: Выходя за рамки стандартного JSON, вы создаете нестандартный формат, который могут не понять другие системы.
