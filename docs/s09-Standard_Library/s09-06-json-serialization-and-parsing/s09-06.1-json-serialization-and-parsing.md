# JSON в JavaScript

Работа с JSON в JavaScript - это один из фундаментальных навыков, который понадобится вам при сохранении данных, обмене информацией с сервером или взаимодействии с другими программами.

## Что такое сериализация?

Представьте, что ваша программа работает с данными: объектами, массивами, строками. Эти данные находятся в оперативной памяти (in-memory) в удобном для JavaScript виде. Но что, если вам нужно сохранить эти данные в файл или отправить их по сети другому компьютеру или программе?

Для этого их необходимо преобразовать в универсальный, компактный и текстовый формат — последовательность байт или символов. Этот процесс преобразования сложных структур данных в такой поток называется **сериализацией** (иногда его также называют маршалингом или "консервацией" — pickling).

Обратный процесс — восстановление исходных данных из сериализованной строки — называется **десериализацией** или **парсингом**.

## JSON — универсальный формат для обмена данными

Самый простой и популярный способ сериализации в JavaScript — использование формата **JSON** (JavaScript Object Notation). Как следует из названия, этот формат использует синтаксис литералов объектов и массивов JavaScript для представления данных.

JSON поддерживает:
*   Примитивные типы: числа и строки.
*   Логические значения: `true` и `false`.
*   "Пустое" значение: `null`.
*   Массивы и объекты, составленные из вышеперечисленных элементов.

**Важное ограничение:** JSON не поддерживает многие специфические для JavaScript типы данных, такие как:
*   `Map`, `Set`
*   `RegExp` (регулярные выражения)
*   `Date` (дата и время)
*   Типизированные массивы (например, `Uint8Array`)
*   Функции
*   `undefined`

Несмотря на это, JSON оказался невероятно универсальным и стал стандартом *de facto* для обмена данными в вебе, используемым далеко за пределами экосистемы JavaScript.

## Базовые методы: `JSON.stringify()` и `JSON.parse()`

JavaScript предоставляет две глобальные функции для работы с JSON.

**`JSON.stringify(value[, replacer[, space]])`**
Преобразует (сериализует) переданное значение в строку JSON.

**`JSON.parse(text[, reviver])`**
Преобразует (парсит) строку JSON обратно в объект JavaScript.

Давайте посмотрим на простейший пример:

```javascript
// Создаем объект
let character = {
  name: "Alice",
  level: 30,
  inventory: ["sword", "shield", null],
  isActive: true
};

// 1. СЕРИАЛИЗУЕМ (Преобразуем в строку)
let jsonString = JSON.stringify(character);
console.log(jsonString);
// Результат: '{"name":"Alice","level":30,"inventory":["sword","shield",null],"isActive":true}'

// 2. ДЕСЕРИАЛИЗУЕМ (Преобразуем обратно в объект)
let parsedObject = JSON.parse(jsonString);
console.log(parsedObject);
// Результат: {name: "Alice", level: 30, inventory: ["sword", "shield", null], isActive: true}
```
Обратите внимание, что `parsedObject` — это новый объект, который не имеет никакой связи с исходным `character`.

## Создание глубокой копии объекта

Интересный побочный эффект этой пары функций — возможность создать **глубокую копию** объекта (копию, в которой рекурсивно копируются все вложенные объекты и массивы, а не просто ссылки на них).

```javascript
// Функция для создания глубокой копии любого сериализуемого объекта
function deepCopy(obj) {
  return JSON.parse(JSON.stringify(obj));
}

let original = { a: 1, b: { c: 2 } };
let copy = deepCopy(original);

console.log(original.b === copy.b); // false -> это разные объекты в памяти!
```
**Важно:** Этот метод неэффективен для больших объектов и не работает, если объект содержит неподдерживаемые JSON типы (например, `Date` или `Function`).

## JSON — это подмножество JavaScript

Строка, которую возвращает `JSON.stringify()`, является валидным кодом JavaScript. Если вы добавите в ее начало, например, `var data = ` и выполните с помощью `eval()`, вы получите объект.

**НО ДЕЛАТЬ ЭТОГО НЕЛЬЗЯ НИКОГДА!**
```javascript
// НИКОГДА ТАК НЕ ДЕЛАЙТЕ!
let dangerousString = `{"name": "User"}`;
let evilData = eval("(" + dangerousString + ")"); // Очень опасно!
```
Использование `eval()` — это огромная дыра в безопасности, так как злоумышленник может вставить в строку произвольный вредоносный код, который выполнится на вашем сайте. Всегда используйте безопасный `JSON.parse()`.

Также помните, что JSON — это *строгое* подмножество. В нем:
*   Не допускаются комментарии.
*   Все имена свойств должны быть в **двойных кавычках** (`"name"`), а не в одиночных и не без них.

## Форматирование вывода для читаемости

Третий необязательный аргумент `JSON.stringify()` управляет форматированием итоговой строки, делая ее удобочитаемой для человека (например, для файлов конфигурации).

*   Если передать **число**, оно укажет количество пробелов для одного уровня отступа.
*   Если передать **строку** (например, `'\t'`), для отступа будет использоваться эта строка (символ табуляции).

```javascript
let data = { a: 1, b: { c: 2, d: [3, 4] } };

// Форматируем с 2 пробелами на уровень
let prettyJson = JSON.stringify(data, null, 2);
console.log(prettyJson);
```
Результат:
```json
{
  "a": 1,
  "b": {
    "c": 2,
    "d": [
      3,
      4
    ]
  }
}
```
Второй аргумент мы пока пропускаем, передавая `null`. `JSON.parse()` игнорирует все пробелы и переводы строк, поэтому такой "красивый" вывод никак не повлияет на процесс парсинга.

## Метод `toJSON()`

Если `JSON.stringify()` встречает значение, которое не умеет сериализовать (например, `Date`), он ищет у этого объекта метод `toJSON()`. Если метод найден, `stringify()` вызывает его и сериализует возвращаемое значение.

Объект `Date` уже имеет встроенный метод `toJSON()`, который возвращает строку в стандартном ISO-формате (то же, что и `toISOString()`).

```javascript
let objWithDate = {
  event: "Meeting",
  date: new Date() // Объект Date
};

let jsonOutput = JSON.stringify(objWithDate);
console.log(jsonOutput);
// Результат: '{"event":"Meeting","date":"2023-10-25T12:00:00.000Z"}'
// Обратите внимание: date стал строкой!
```

## Функция-"оживитель" (reviver) в `JSON.parse()`

После парсинга строки мы получаем объект, где `date` — это строка, а не объект `Date`. Как это исправить? Для кастомизации процесса парсинга используется второй необязательный аргумент `JSON.parse()` — **функция-reviver**.

Эта функция вызывается для **каждой пары "ключ-значение"** в создаваемом объекте, начиная с самых вложенных свойств.

**Как она работает:**
*   **Аргумент 1 (`key`)**: Имя свойства (или строковое представление индекса массива).
*   **Аргумент 2 (`value`)**: Значение этого свойства.
*   **Контекст (`this`)**: Ссылается на содержащий объект или массив.

Функция может вернуть:
*   **Исходное `value`**: свойство останется без изменений.
*   **Другое значение**: оно будет заменено на возвращенное.
*   **`undefined`**: это свойство будет полностью удалено из результата.

**Пример: оживляем даты и фильтруем свойства**
```javascript
let jsonText = '{"event":"Meeting","date":"2023-10-25T12:00:00.000Z", "_secretNote":"For admin only"}';

let parsedData = JSON.parse(jsonText, function(key, value) {
  // 1. Удаляем все свойства, начинающиеся с нижнего подчеркивания
  if (key.startsWith('_')) return undefined;

  // 2. Если значение - строка, похожая на дату в ISO-формате, преобразуем ее в объект Date.
  if (typeof value === 'string') {
    let isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}.\d{3}Z$/;
    if (isoRegex.test(value)) {
      return new Date(value);
    }
  }

  // 3. Для всех остальных значений возвращаем как есть.
  return value;
});

console.log(parsedData);
// { event: "Meeting", date: 2023-10-25T12:00:00.000Z } // _secretNote удалено!
console.log(parsedData.date instanceof Date); // true -> теперь это объект Date!
```

## Функция-заместитель (replacer) в `JSON.stringify()`

Второй аргумент `JSON.stringify()` также может быть функцией. Она называется **replacer** и является зеркальной по отношению к `reviver` в `JSON.parse()`.

Она вызывается для каждого свойства сериализуемого объекта и также получает ключ и значение. Ее задача — определить, что именно будет сериализовано.

*   Если вернуть `undefined` или ничего, это свойство не попадет в итоговую строку.
*   Если вернуть любое другое значение, будет сериализовано именно оно.

**Пример 1: Замена неподдерживаемых значений**
```javascript
let userData = {
  name: "Bob",
  lastLogin: new Date(),
  password: "secret123", // Не хотим сериализовывать пароль!
  profile: /admin/ // Регулярное выражение -> не сериализуется по умолчанию.
};

let jsonString = JSON.stringify(userData, (key, value) => {
  // Удаляем свойство 'password'
  if (key === 'password') return undefined;

  // Заменяем RegExp на его строковое представление
  if (value instanceof RegExp) return value.toString();

  // Для всех остальных значений оставляем как есть
  return value;
});

console.log(jsonString);
// '{"name":"Bob","lastLogin":"2023-10-25T12:00:00.000Z","profile":"/admin/"}'
// password удален, profile превращен в строку.
```

**Пример 2: Массив-заместитель (простейший случай)**
Второй аргумент может быть не только функцией, но и **массивом строк**. В этом случае в JSON-строку попадут только те свойства, имена которых есть в этом массиве, и именно в том порядке.

```javascript
let address = {
  country: "Russia",
  city: "Moscow",
  street: "Tverskaya",
  building: 25,
  zipCode: "123456"
};

// Сериализуем только конкретные поля в заданном порядке
let serializedAddress = JSON.stringify(address, ["country", "city", "street", "building"]);
console.log(serializedAddress);
// '{"country":"Russia","city":"Moscow","street":"Tverskaya","building":25}'
// zipCode был проигнорирован.
```

## Заключение

Использование методов `toJSON()`, `replacer` и `reviver` позволяет гибко настраивать процесс сериализации и десериализации под нужды вашего приложения.

**Однако помните:** как только вы начинаете сильно кастомизировать процесс (например, сериализовать `RegExp` в строку, а потом парсить ее обратно в объект `RegExp`), вы по сути создаете **собственный формат данных на основе JSON**.

Это жертвует портабельностью и совместимостью с огромной экосистемой инструментов и языков, которые понимают стандартный JSON. Делайте это осознанно, когда преимущества для вашего приложения перевешивают потенциальные недостатки. Для обмена данными с сервером лучше всегда придерживаться стандартного, предсказуемого формата.
