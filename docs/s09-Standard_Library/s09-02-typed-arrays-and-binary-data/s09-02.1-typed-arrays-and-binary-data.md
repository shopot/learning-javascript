# Типизированные массивы и бинарные данные

Обычные массивы в JavaScript могут содержать элементы любого типа и динамически изменять свой размер. Несмотря на оптимизации, они существенно отличаются от массивов в низкоуровневых языках вроде C и Java. Типизированные массивы, появившиеся в ES6, гораздо ближе к массивам этих языков.

Хотя технически типизированные массивы не являются массивами (Array.isArray() возвращает false для них), они реализуют все методы массивов из раздела 7.8 плюс некоторые дополнительные. Ключевые отличия:

- Элементы типизированных массивов — всегда числа, но с возможностью указания типа (знаковые/беззнаковые целые, числа с плавающей точкой) и размера (от 8 до 64 бит)
- Длина задается при создании и не может изменяться
- Элементы инициализируются нулями при создании

## Типы типизированных массивов

В JavaScript нет единого класса TypedArray. Вместо этого существует 11 видов типизированных массивов с разными конструкторами:

| Конструктор           | Числовой тип                     |
|-----------------------|----------------------------------|
| Int8Array()           | знаковые байты                   |
| Uint8Array()          | беззнаковые байты                |
| Uint8ClampedArray()   | беззнаковые байты без переполнения |
| Int16Array()          | знаковые 16-битные целые         |
| Uint16Array()         | беззнаковые 16-битные целые      |
| Int32Array()          | знаковые 32-битные целые         |
| Uint32Array()         | беззнаковые 32-битные целые      |
| BigInt64Array()       | знаковые 64-битные BigInt (ES2020) |
| BigUint64Array()      | беззнаковые 64-битные BigInt (ES2020) |
| Float32Array()        | 32-битные числа с плавающей точкой |
| Float64Array()        | 64-битные числа с плавающей точкой |

Типы с префиксом Int хранят знаковые целые (1, 2 или 4 байта), Uint — беззнаковые. BigInt-типы работают с 64-битными целыми, представленными как BigInt. Float-типы хранят числа с плавающей точкой.

Uint8ClampedArray — особый вариант Uint8Array, который ограничивает значения диапазоном 0-255 вместо циклического переполнения. Это поведение требуется API элемента `<canvas>` для работы с цветами пикселей.

Каждый конструктор имеет свойство BYTES_PER_ELEMENT со значением 1, 2, 4 или 8 в зависимости от типа.

## Создание типизированных массивов

Самый простой способ — вызов конструктора с числовым аргументом (количество элементов):

```javascript
let bytes = new Uint8Array(1024);    // 1024 байта
let matrix = new Float64Array(9);    // Матрица 3x3
let point = new Int16Array(3);       // Точка в 3D пространстве
let rgba = new Uint8ClampedArray(4); // 4-байтовое RGBA значение
let sudoku = new Int8Array(81);      // Доска судоку 9x9
```

При таком создании все элементы инициализируются нулями (0, 0n или 0.0).

Для инициализации значениями используйте статические методы from() и of():

```javascript
let white = Uint8ClampedArray.of(255, 255, 255, 0); // RGBA непрозрачный белый
```

Метод from() ожидает массивоподобный или итерируемый объект с числовыми элементами. Конструкторы также поддерживают этот синтаксис:

```javascript
let ints = Int32Array.from([1, 2, 3, 4]); // Массив 32-битных целых
```

Значения автоматически приводятся к целевому типу с усечением при необходимости:

```javascript
Uint8Array.of(1.23, 2.99, 45000) // => new Uint8Array([1, 2, 200])
```

## Работа с ArrayBuffer

ArrayBuffer — ссылка на блок памяти. Создается через конструктор:

```javascript
let buffer = new ArrayBuffer(1024*1024); // 1 мегабайт памяти
buffer.byteLength // => 1048576
```

ArrayBuffer не позволяет напрямую читать/писать байты. Для этого нужны типизированные массивы:

```javascript
let asbytes = new Uint8Array(buffer);        // Просмотр как байты
let asints = new Int32Array(buffer);         // Просмотр как 32-битные целые
let lastK = new Uint8Array(buffer, 1023*1024); // Последний килобайт как байты
let ints2 = new Int32Array(buffer, 1024, 256); // Второй килобайт как 256 целых
```

Второй аргумент — смещение в байтах, третий — количество элементов. Смещение должно быть кратно размеру элемента.

## Использование типизированных массивов

Доступ к элементам — через квадратные скобки как в обычных массивах:

```javascript
// Решето Эратосфена
function sieve(n) {
    let a = new Uint8Array(n+1);         // a[x] = 1 если x составное
    let max = Math.floor(Math.sqrt(n));  // Максимальный множитель
    let p = 2;                           // Первое простое число
    
    while(p <= max) {
        for(let i = 2*p; i <= n; i += p) // Помечаем кратные p как составные
            a[i] = 1;
        while(a[++p]) /* empty */;       // Следующее непомеченное - простое
    }
    
    while(a[n]) n--;                     // Ищем последнее простое
    return n;
}
```

Такой код работает в 4 раза быстрее и использует в 8 раз меньше памяти по сравнению с обычными массивами.

## Методы и свойства типизированных массивов

Типизированные массивы поддерживают большинство методов обычных массивов:

```javascript
let ints = new Int16Array(10);     // 10 коротких целых
ints.fill(3).map(x => x*x).join("") // => "9999999999"
```

Методы, изменяющие длину (push, pop, unshift, shift, splice) не поддерживаются. Методы, возвращающие новые массивы (map, slice), возвращают типизированный массив того же типа.

Специфические методы типизированных массивов:

**set()** — копирует элементы из другого массива:

```javascript
let bytes = new Uint8Array(1024);
let pattern = new Uint8Array([0, 1, 2, 3]);
bytes.set(pattern);        // Копирование в начало
bytes.set(pattern, 4);     // Копирование со смещением 4
bytes.set([0, 1, 2, 3], 8); // Копирование из обычного массива
```

**subarray()** — возвращает представление части массива:

```javascript
let ints = new Int16Array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
let last3 = ints.subarray(ints.length-3, ints.length); // Последние 3 элемента
```

В отличие от `slice()`, `subarray()` не копирует данные, а создает новое представление тех же данных.

## Свойства buffer, byteOffset и byteLength

Каждый типизированный массив имеет связь с ArrayBuffer:

```javascript
last3.buffer                  // ArrayBuffer объекта
last3.buffer === ints.buffer  // true: тот же буфер
last3.byteOffset              // 14: начало в байте 14 буфера
last3.byteLength              // 6: длина 6 байт (3 элемента)
last3.buffer.byteLength       // 20: общий размер буфера 20 байт
```

Инвариант: `a.length * a.BYTES_PER_ELEMENT === a.byteLength`

## DataView и порядок байтов

Типизированные массивы используют порядок байтов (endianness) underlying платформы. Для определения порядка байтов:

```javascript
// Если 0x00000001 представлено как 01 00 00 00 - little-endian
let littleEndian = new Int8Array(new Int32Array([1]).buffer)[0] === 1;
```

DataView позволяет явно указывать порядок байтов при работе с данными:

```javascript
let view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);

let int = view.getInt32(0);           // Чтение big-endian целого с позиции 0
int = view.getInt32(4, false);        // Следующее целое тоже big-endian  
int = view.getUint32(8, true);        // Беззнаковое little-endian целое
view.setUint32(8, int, false);        // Запись в big-endian формате
```

`DataView` предоставляет методы `getInt16()`, `getUint32()`, `getBigInt64()`, `getFloat64()` и соответствующие set-методы. Второй аргумент (для многобайтовых методов) определяет порядок байтов: `false` или пропуск — big-endian, `true` — little-endian.

## Заключение

Типизированные массивы и `DataView` предоставляют мощные инструменты для работы с бинарными данными в JavaScript, позволяя эффективно обрабатывать данные из файлов, сетевых соединений и других низкоуровневых источников.
