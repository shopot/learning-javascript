# Список ответов по теме "Типизированные массивы и бинарные данные"

1. Типизированные массивы содержат элементы только числового типа с фиксированным размером, имеют фиксированную длину и инициализируются нулями, в отличие от обычных массивов, которые могут содержать элементы любого типа и динамически менять размер.

2. Три ключевых отличия: элементы всегда числа определенного типа и размера, длина задается при создании и не меняется, элементы инициализируются нулями.

3. Потому что типизированные массивы не являются настоящими массивами - они реализуют большинство методов массивов, но технически представляют собой другой тип объектов.

4. В JavaScript существует 11 видов типизированных массивов, каждый со своим конструктором.

5. Int8Array хранит знаковые байты (от -128 до 127), а Uint8Array - беззнаковые байты (от 0 до 255).

6. Uint8ClampedArray ограничивает значения диапазоном 0-255 без переполнения, что используется в API canvas для работы с цветами пикселей.

7. BigInt64Array для знаковых и BigUint64Array для беззнаковых 64-битных целых чисел, представленных как BigInt.

8. Размер определяется свойством BYTES_PER_ELEMENT конструктора: 1, 2, 4 или 8 байт в зависимости от типа.

9. Через конструктор с длиной, через методы from()/of(), или через ArrayBuffer с указанием смещения и длины.

10. Значение "завернется" по модулю 256 - например, 256 станет 0, 257 станет 1, и т.д.

11. ArrayBuffer - это объект, представляющий блок сырой бинарной памяти, который используется как основа для типизированных массивов.

12. Создав несколько типизированных массивов с одним и тем же buffer, но разными типами или смещениями.

13. Нет, длина типизированного массива фиксируется при создании и не может быть изменена.

14. Методы, изменяющие длину массива: push(), pop(), unshift(), shift(), splice().

15. Метод set() копирует элементы из другого массива или типизированного массива в текущий массив.

16. subarray() создает новое представление тех же данных без копирования, а slice() создает новый массив с копией данных.

17. buffer - ссылка на ArrayBuffer, byteOffset - смещение в байтах от начала буфера, byteLength - длина данных в байтах.

18. Порядок байтов определяет, как байты располагаются в памяти для многобайтовых чисел. Важен для совместимости между разными системами.

19. Создав Int32Array со значением 1 и проверив первый байт: если равен 1 - little-endian, если 0 - big-endian.

20. DataView используется для работы с бинарными данными с явным указанием порядка байтов, особенно когда нужна кроссплатформенная совместимость.

21. DataView предоставляет методы getInt8(), getUint16(), getInt32(), getFloat64() и другие для чтения данных с указанием смещения и порядка байтов.

22. Используя методы setInt32(), setUint16() и т.д. с третьим аргументом false для big-endian или true для little-endian.

23. Для обработки бинарных данных: работа с изображениями, аудио, видео, сетевыми протоколами, файловыми форматами, криптографией и любыми другими низкоуровневыми данными.

