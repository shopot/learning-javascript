# Ответы

1. **Примитивные типы в JavaScript**: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`.  
   *Объяснение*: Это базовые типы, которые не являются объектами и не имеют методов.

2. **`typeof null` возвращает `"object"`** — это баг в JavaScript, сохраняемый для совместимости.  
   *Объяснение*: В ранних версиях JS `null` был представлен как пустой указатель на объект, и этот поведение не исправили.

3. **`typeof Symbol("id")` вернёт `"symbol"`**.  
   *Объяснение*: `Symbol` — уникальный неизменяемый примитив, и `typeof` корректно его определяет.

4. **Правильное использование `typeof`**:
  - `typeof x`
  - `typeof(x)`  
    *Объяснение*: Оба варианта работают, второй — синтаксический сахар.

5. **`console.log(typeof undefined)` выведет `"undefined"`**.  
   *Объяснение*: `undefined` — отдельный примитивный тип.

6. **`typeof 123n` вернёт `"bigint"`**.  
   *Объяснение*: `BigInt` — отдельный тип для больших чисел.

7. **`String(42)` преобразует число в строку `"42"`**.  
   *Объяснение*: Явное приведение к строке.

8. **`Number("Hello")` вернёт `NaN`**, потому что строка не является числом.  
   *Объяснение*: Неудачное преобразование даёт `NaN`.

9. **Ложные (`falsy`) значения**: `false`, `0`, `""`, `null`, `undefined`, `NaN`.  
   *Объяснение*: Эти значения при `Boolean()` дают `false`.

10. **`Boolean("false")` вернёт `true`**, потому что непустая строка — `truthy`.  
    *Объяснение*: Ложным является только пустая строка `""`.

11. **`console.log("5" - 2)` выведет `3`**, потому что `-` вызывает численное преобразование.  
    *Объяснение*: Оператор `-` не работает со строками, поэтому JS приводит типы.

12. **`console.log("5" + 2)` выведет `"52"`**, потому что `+` конкатенирует строки.  
    *Объяснение*: `+` может означать и сложение, и конкатенацию — приоритет у строк.

13. **`null + 1 = 1`**, потому что `null` при численном преобразовании даёт `0`.  
    **`undefined + 1 = NaN`**, потому что `undefined` превращается в `NaN`.

14. **Способы преобразования `"123"` в число**:
  - `Number("123")`
  - `+"123"`
  - `parseInt("123")`

15. **Проверка на `NaN`**: `isNaN(value)` или `Number.isNaN(value)`.  
    *Объяснение*: `NaN` не равен сам себе (`NaN === NaN` → `false`).

16. **`console.log(Boolean([]))` выведет `true`**, потому что массив — объект (а объекты `truthy`).  
    *Доп. объяснение*: Пустой массив — всё равно объект, а не `false`.

17. **`Number("")` возвращает `0`**, потому что пустая строка приводится к `0`.  
    *Объяснение*: Это особенность JS, в других языках может быть `NaN`.

18. **Опасность неявного преобразования**:  
    Пример: `"5" + 1 = "51"` (ожидали `6`).  
    *Объяснение*: Неочевидное поведение при операциях.

19. **Как избежать**: Явно приводить типы:
    ```js  
    const sum = Number("5") + 1; // 6  
    ```  

20. **Проверка на число (с учётом `NaN`)**:
    ```js  
    function isNumber(x) {  
      return typeof x === "number" && !isNaN(x);  
    }  
    ```  

21. **`==` vs `===`**:
  - `==` допускает приведение типов (`"5" == 5` → `true`).
  - `===` проверяет тип и значение (`"5" === 5` → `false`).

22. **Неявное преобразование**: Автоматическое приведение типов, например:  
    `"5" * 2` → `10` (строка превращается в число).

23. **Явное преобразование**: Программист сам указывает тип:  
    `Number("5")`, `String(10)`.

24. **Операции с неявным преобразованием**:
  - `+` (если есть строки), `-`, `*`, `/`, `==`, `if (value)`.

25. **`console.log(1 + "2" + 3)` → `"123"`**, потому что `1 + "2" = "12"`, затем `"12" + 3 = "123"`.

26. **Разница между `"5" - 2` и `"5" + 2`**:
  - `-` всегда численное преобразование (`3`).
  - `+` конкатенирует, если есть строка (`"52"`).

27. **`console.log([] + {})` → `"[object Object]"`**, потому что:
  - `[]` → `""` (пустая строка),
  - `{}` → `"[object Object]"`.

28. **`"0" == false` → `true`**, потому что:
  - `false` → `0`,
  - `"0"` → `0` (неявное преобразование).

29. **`console.log(null == undefined)` → `true`**, это специальное правило JS.

30. **Три способа строку → число**:
  - `Number(str)`,
  - `+str`,
  - `parseInt(str)`.

31. **`parseInt("10px")` → `10`**, он извлекает число, а `Number("10px")` → `NaN`.

32. **Число → строка**:
  - `42 + ""` → `"42"`.

33. **`Boolean([])` → `true`**, потому что любой объект (включая массив) — `truthy`.

34. **`" " == false` → `true`**, потому что:
  - `" "` → `0` (пробел не пустой),
  - `false` → `0`.

35. **Как избежать**:
    ```js  
    const result = Number(a) + Number(b);  
    ```  

36. **Опасность `==`**:  
    Пример: `0 == false` → `true` (неочевидно). Лучше `===` для строгого сравнения.

37. **`console.log(+"")` → `0`**, потому что пустая строка приводится к `0`.
