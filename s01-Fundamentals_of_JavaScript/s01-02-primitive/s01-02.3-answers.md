# Ответы на вопросы по примитивам и объектам-обёрткам

#### **1. Какие 7 примитивных типов данных существуют в JavaScript?**
✅ `string`, `number`, `bigint`, `boolean`, `symbol`, `undefined`, `null`.

#### **2. Почему примитивы называют *неизменяемыми* (immutable)? Приведите пример.**
✅ Примитивы нельзя изменить после создания. Например:
```javascript
let str = "hello";
str[0] = "H"; // Не изменит строку
console.log(str); // "hello" (осталось без изменений)
```
В отличие от объектов, где свойства можно модифицировать.

#### **3. Как динамическая типизация в JavaScript влияет на работу с примитивами?**
✅ Тип переменной определяется в момент присваивания значения и может меняться:
```javascript
let x = 10; // number
x = "text"; // string (динамическое изменение типа)
```

#### **4. Может ли переменная, содержащая примитив, изменить своё значение? А сам примитив?**
✅ **Переменной** можно присвоить новое значение (даже другого типа), но **сам примитив** изменить нельзя (он immutable).

#### **5. Какие примитивные типы имеют объекты-обёртки?**
✅ Все, кроме `null` и `undefined`:
- `String` для `string`
- `Number` для `number`
- `Boolean` для `boolean`
- `BigInt` для `bigint`
- `Symbol` для `symbol`

#### **6. Почему у `null` и `undefined` нет объектов-обёрток?**
✅ Они представляют отсутствие значения, и попытка вызвать у них метод приведёт к ошибке (например, `null.toString()` → `TypeError`).

#### **7. Что происходит, когда вы вызываете метод у примитива (например, `'abc'.toUpperCase()`)?**
✅ JavaScript временно оборачивает примитив в объект (`new String('abc')`), вызывает метод, а затем возвращает примитив.

#### **8. Какой метод объекта-обёртки возвращает исходное примитивное значение?**
✅ `valueOf()`:
```javascript
const numObj = new Number(42);
console.log(numObj.valueOf()); // 42 (number)
```

#### **9. Чем отличается `typeof 5` от `typeof new Number(5)`?**
✅
- `typeof 5` → `"number"` (примитив)
- `typeof new Number(5)` → `"object"` (объект-обёртка)

#### **10. Почему `5 === new Number(5)` возвращает `false`?**
✅ Потому что `new Number(5)` — это объект, а `5` — примитив. Они разных типов (`number` vs `object`).

#### **11. В каких случаях может быть полезно явное создание объекта-обёртки?**
✅ Почти никогда. Иногда — для расширения методов (например, `Number.prototype.myMethod = ...`), но это считается плохой практикой.

#### **12. Что произойдёт, если попытаться вызвать метод у `null` или `undefined`?**
✅ Будет ошибка:
```javascript
null.toString(); // TypeError: Cannot read property 'toString' of null
undefined.toString(); // Аналогично
```

#### **13. Какой будет результат выполнения кода?**
```javascript
const bool = true;
console.log(bool.valueOf());  
```
✅ `true` (возвращает примитивное значение `boolean`).

#### **14. Почему рекомендуется использовать примитивы вместо явного создания объектов-обёрток?**
✅ Объекты-обёртки усложняют код (например, `new Number(5) + 1` работает, но `typeof new Number(5)` — `"object"`, что может сбивать с толку).

#### **15. Что такое *автоупаковка* (autoboxing) в JavaScript?**
✅ Автоматическое преобразование примитива в объект-обёртку при вызове методов (например, `"text".length` → временно создаётся `new String("text")`).

#### **16. Можно ли добавить свой метод к объекту-обёртке (например, `Number.prototype`)?**
✅ Да, но это плохая практика (может повлиять на весь код):
```javascript
Number.prototype.square = function() { return this ** 2; };
console.log((5).square()); // 25
```

#### **17. Какой объект-обёртка используется для работы с `BigInt`?**
✅ `BigInt` (но он не может быть вызван с `new`, только как функция: `BigInt(10)`).

#### **18. Какие примитивы не имеют методов и почему?**
✅ `null` и `undefined` — они обозначают отсутствие значения, и попытки вызвать методы приводят к ошибкам.

#### **19. В чём главное отличие примитивов от объектов (кроме мутабельности)?**
✅ Примитивы:
- Не имеют свойств/методов (кроме автоупаковки).
- Сравниваются **по значению** (`5 === 5` → `true`).  
  Объекты:
- Имеют свойства и методы.
- Сравниваются **по ссылке** (`{} === {}` → `false`).

#### **20. Когда JavaScript автоматически применяет объекты-обёртки?**
✅ При вызове методов у примитивов (например, `"abc".toUpperCase()`) или обращении к свойствам (например, `"hello".length`).

