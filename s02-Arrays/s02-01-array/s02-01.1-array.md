# Массивы

## Создание массивов

В JavaScript существует несколько способов создания массивов.
Вот основные из них:

### Литерал массива (`[]`)

Самый простой и распространённый способ.

```javascript
const arr = [1, 2, 3, 4, 5];
console.log(arr);
// [ 1, 2, 3, 4, 5 ]
```

### Конструктор `Array()`

Можно использовать конструктор `new Array()`, но он менее предпочтителен из-за неочевидного поведения.

```javascript
const arr1 = new Array(); // Пустой массив []
const arr2 = new Array(5); // Массив с length = 5 (но без элементов) [ <5 empty items> ]
const arr3 = new Array(1, 2, 3); // [1, 2, 3]
```

### `Array.of()`

Создаёт массив из переданных аргументов, в отличие от `new Array()`, корректно обрабатывает единичный числовой аргумент.

```javascript
const arr = Array.of(1, 2, 3); // [1, 2, 3]
const single = Array.of(5); // [5] (в отличие от new Array(5), который создаёт пустую длину 5
```

### `Array.from()`

Создаёт массив из итерируемого объекта или массивоподобного объекта (например, `arguments`, `NodeList`, строки).

```javascript
const strArr = Array.from('hello'); // ['h', 'e', 'l', 'l', 'o']
const setArr = Array.from(new Set([1, 2, 2, 3])); // [1, 2, 3]
const argsArr = Array.from(arguments); // Преобразование arguments в массив
```

### `Array()` без `new`

Работает аналогично `new Array()`, но лучше избегать такого синтаксиса.

```javascript
const arr = Array(1, 2, 3); // [1, 2, 3]
```

### С помощью метода `split()` (для строк)

Позволяет создать массив из строки по разделителю.

```javascript
const str = 'a,b,c';
const arr = str.split(','); // ['a', 'b', 'c']
```

### Spread-оператор (`...`)

Можно использовать для создания копии или объединения массивов.

```javascript
const copy = [...[1, 2, 3]]; // [1, 2, 3]
const merged = [...[1, 2], ...[3, 4]]; // [1, 2, 3, 4]
```

### С помощью генераторов или `Array.from()` с функцией-маппером

```javascript
const generated = Array.from({ length: 5 }, (v, i) => i * 2); // [0, 2, 4, 6, 8]
```

- Лучший способ для большинства случаев → литерал массива `[]` (просто и эффективно).
- Для преобразования итерируемых объектов → `Array.from()`.
- Для заполнения массивов → `Array.from()` + функция или `fill()`.
- Конструктор `new Array()` лучше избегать из-за неочевидного поведения.

## Доступ к элементам

### Доступ по индексу (стандартный способ)

Если необходимо получить определенное значение из массива, нужно указать имя массива,
добавить квадратные скобки в конце и вписать в них индекс, к которому мы хотим
получить доступ.

Массивы индексируются с `0`, поэтому можно получить элемент, указав его индекс в квадратных скобках:

```javascript
const arr = ['a', 'b', 'c'];

console.log(arr[0]); // 'a'
console.log(arr[2]); // 'c'
console.log(arr[3]); // undefined (нет такого индекса)
```

### Отрицательные индексы с помощью `at()` (ECMAScript® 2026)

Метод `Array.prototype.at()` позволяет использовать отрицательные индексы (как в Python):

```javascript
const arr = ['a', 'b', 'c'];
console.log(arr.at(-1)); // 'c' (последний элемент)
console.log(arr.at(-2)); // 'b' (предпоследний)
console.log(arr.at(1));  // 'b' (аналог arr[1])
```

### Доступ через деструктуризацию

Можно извлекать элементы в отдельные переменные:

```javascript
const [first, second, third] = ['a', 'b', 'c'];
console.log(first);  // 'a'
console.log(second); // 'b'
console.log(third);  // 'c'
```

Пропуск элементов:

```javascript
const [first, , third] = ['a', 'b', 'c']; // Пропускаем второй элемент
console.log(first, third); // 'a', 'c'
```

Остаточные параметры (`...rest`):

```javascript
const [first, ...rest] = ['a', 'b', 'c'];
console.log(rest); // ['b', 'c']
```

### Доступ через методы массива

Некоторые методы возвращают элементы или части массива:

- **`find()`** – первый элемент, удовлетворяющий условию:
  ```javascript
  const numbers = [1, 2, 3, 4];
  const firstEven = numbers.find(num => num % 2 === 0);
  console.log(firstEven); // 2
  ```

- **`slice()`** – часть массива (не изменяет оригинал):
  ```javascript
  const arr = ['a', 'b', 'c', 'd'];
  console.log(arr.slice(1, 3)); // ['b', 'c']
  ```

- **`pop()` / `shift()`** – извлекают первый/последний элемент (мутируют массив):
  ```javascript
  const arr = [1, 2, 3];
  const last = arr.pop();
  console.log(last, arr); // 3, [1, 2]
  ```

- Для обычного доступа → **индекс `arr[i]`** или **`at()`** (если нужны отрицательные индексы).
- Для извлечения нескольких элементов → **деструктуризация**.
- Для поиска по условию → **`find()` / `filter()`**.
- Для проверки наличия → **`includes()`**.

## Встроенное свойство длины `length`

Массивы обладают очень полезным свойством: длиной. Она возвращает количество
значений, которые содержит массив:

```javascript
const colors = ["black", "orange", "pink"]
const booleans = [true, false, false, true];
const emptyArray = [];

console.log("Length of colors:", colors.length);
console.log("Length of booleans:", booleans.length);
console.log("Length of empty array:", emptyArray.length);

// Length of colors: 3
// Length of booleans: 4
// Length of empty array: 0
```

Имейте в виду, что длина на единицу превышает максимальный индекс (потому что
индекс массива начинается с 0). 

Доступ к последнему элементу массива:

```javascript
const lastElement = colors[colors.length - 1];
```

## Пустые элементы при прямом присваивании по индексу

Если присвоить значение элементу массива по индексу, который превышает текущую длину, JavaScript автоматически расширит массив, заполнив пропущенные позиции "пустыми слотами" (empty items).

```javascript
const numbers = [12, 24, 36];
numbers[5] = 48; // Прямое присваивание в индекс 5
console.log(numbers.length); // 6 (индексы 0-5)
console.log(numbers); // [12, 24, 36, <2 empty items>, 48]
```  

Почему так?

- Массивы в JavaScript **нумеруются с `0`**, и их длина (`length`) определяется по **наибольшему индексу + 1**.
- Пропущенные индексы (`3` и `4`) становятся "пустыми" (но не `undefined`!).

Проблемы такого подхода:

1. **Пустые слоты** ведут себя не так, как `undefined`:
   ```javascript
   console.log(numbers[3]); // undefined, но массив НЕ содержит явного `undefined`!
   ```  
2. **Методы массива** (например, `map`, `forEach`) **игнорируют пустые элементы**.

### Как правильно добавлять элементы?

Вместо прямого присваивания по индексу используйте:

- **`push()`** для добавления в конец:
  ```javascript
  numbers.push(48); // Безопасно увеличивает длину.  
  ```  
- **`splice()`** для вставки в середину:
  ```javascript
  numbers.splice(5, 0, 48); // Вставляет 48 в позицию 5, сдвигая остальные.  
  ```  

